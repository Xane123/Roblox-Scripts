--[[
	XANE'S RECREATOR API, WRITTEN IN 2024
	LAST UPDATED ON AUGUST 14TH, 2024
	
	A script that adds common functions to any Roblox script intended for saving
	most instances to JSON files, which can be used with Xane's Asset Importer, a
	Roblox Studio plugin! This script is used (automatically loaded) by my main
	scripts, such as "Xane's Model Recreator" and "RH Accessory Preserver",
	letting me do the main thing I use exploits for, to save models and assets
	from Roblox games, especially Royale High.
	
	There aren't any instructions for how you can utilize this API in your
	scripts yet, but you can look at and modify Xane's Model Recreator's code,
	which loads this code using a LoadString, adding its functions and variables
	under getgenv().XRecreator. From here, call
	getgenv().XRecreator.Activate(true), then you can use functions like
	getgenv().XRecreator.Select("set", {[instances]}) to select things and
	getgenv().XRecreator.Save("[filename without JSON extension") to save those
	instances and their descendants to JSON files. If you're a good scripter,
	you'll quickly learn how to use this "API" to your advantage!
]]--

-- Comments with four hyphens before them relate to Xane's Model Recreator's "message" instance; Since this script was split from it,
-- it included references to part of its GUI, which shouldn't be modified by a script that's intended to be used for general saving
-- scripts. I don't know what to do with the references so they were commented out if they weren't turned into DisplayError() calls.

if not game:IsLoaded() then game.Loaded:Wait() end
task.wait(0.2)
print("Xane's model recreation API is initializing... (Please work!)")

local CoreGui								= game:GetService("CoreGui")

-- The recreator's API has to display its current status somewhere! While other scripts can link it to a TextLabel, it'll use its own GUI
-- if one isn't provided. (This wasn't generated by the usual GUI to Lua plug-in!)
local built_in_gui : ScreenGui				= CoreGui:FindFirstChild("RecreatorFallbackGUI")
local built_in_status : TextLabel			= nil
local built_in_error : TextLabel			= nil
if not built_in_gui then
	built_in_gui							= Instance.new("ScreenGui")
	built_in_gui.Name						= "RecreatorFallbackGUI"
	built_in_gui.IgnoreGuiInset				= true
	built_in_gui.Enabled					= true
	built_in_gui.Parent						= CoreGui
end
built_in_status								= built_in_gui:FindFirstChild("StatusLabel")
if not built_in_status then
	built_in_status							= Instance.new("TextLabel")
	built_in_status.Name					= "StatusLabel"
	built_in_status.AnchorPoint				= Vector2.one / 2
	built_in_status.Position				= UDim2.fromScale(0.5, 0.5)
	built_in_status.BackgroundColor3		= Color3.new(0.2, 0.25, 0.4)
	built_in_status.BackgroundTransparency	= 0.25
	built_in_status.TextColor3				= Color3.new(0.8125,0.625,0.95)
	built_in_status.TextStrokeColor3		= Color3.new(0.125,0.0925,0.0475)
	built_in_status.TextStrokeTransparency	= 0
	built_in_status.Text					= "Indexing instances... (1/10)"
	built_in_status.Visible					= false
	built_in_status.Parent					= built_in_gui
end
built_in_error								= built_in_gui:FindFirstChild("ErrorMessage")
if not built_in_error then
	built_in_error							= Instance.new("TextLabel")
	built_in_error.Name						= "ErrorMessage"
	built_in_error.AnchorPoint				= Vector2.new(0.5, 1)
	built_in_error.Position					= UDim2.fromScale(0.5, 0.875)
	built_in_error.BackgroundColor3			= Color3.new(0.125, 0.125, 0.125)
	built_in_error.BackgroundTransparency	= 0.125
	built_in_error.TextColor3				= Color3.new(1, 0.95, 0.975)
	built_in_error.Text						= "Something went wrong. Please try again later."
	built_in_error.Visible					= false
	built_in_error.Parent					= built_in_gui
end

-- All Recreator-related functions will be added to the executor's private environment/dictionary entry so any scripts that utilize
-- them can control my iffy "API" and easily save any instance to a JSON file.
local env				= getgenv and getgenv() or _G
if not env then error("Your executor sucks! Couldn't find a suitable environment for Xane's recreator API.") end
if not env.XRecreator then
	env.XRecreator = {
		Select				= nil,		-- Public functions
		MakeList			= nil,
		Save				= nil,
		ActivateAPI			= nil,
		EmptyDebugIDCache	= nil,
		SetStatusGui		= nil,
		
		Reserved			= false,	-- Public variables
		IgnoreAttrib		= "Dummy",
		Selection			= {},
		FullList			= {},
		StatusGui			= built_in_status
	}
end

-- The contents of getgenv().XRecreator after the Recreation API initializes. These functions send commands to the API, making
-- it very easy to automate actions like selecting Instances, saving them to JSON files, and loading stuff FROM those files.
type ModelRecreatorStruct	= {
	-- FUNCTIONS
	Select		: (_mode:"set"|"add"|"remove", _list:{Instance}) -> (),	-- Updates the API's selection.
	MakeList	: (_baseInst : Instance) -> (nil),						-- Generates a series of list entries, for GUI's that display one.
	Save		: (_name:string,_rescan:boolean) -> (boolean),			-- Saves selection to files. Will fail on invalid filenames.
	CustomizeProgressBox:(_message : string, _total : number) -> (),	-- Affects the text shown in "saving"/"indexing" GUI (may be unusable).
	ActivateAPI	: (_use : boolean) -> boolean,							-- Requests to use API functions. If in use, this returns FALSE.
	SetStatusGui: (_gui:TextLabel) -> (nil),							-- Changes GUI that save status is shown in. Set to nil to use default.
	OnSaveDone	: (_success : boolean) -> (),							-- External code ran upon finishing. Used for other scripts' cleanup.
	IsInstanceAllowed : (_instance : Instance) -> (boolean),			-- Checks if an Instance's type is safe to save. (Model Recreator v3)
	Load		: (_header:string,_pieces:{string},_dest:Instance?) -> (XRecreatorImportResult?),	-- Import previously saved JSON instances.
	LoadFile	: (_saveName:string,_dest:Instance?) -> (XRecreatorImportResult?),	-- Loads from a JSON capture set, passing to Load().

	-- VARIABLES
	Reserved	: boolean,												-- Set to TRUE after a script calls ActivateAPI().
	IgnoreAttrib: string,												-- Instances with this attribute won't be scanned.
	Selection	: {Instance},											-- List of instances marked to be saved.
	FullList	: {InternalListEntry},									-- List generated by MakeList(), which can be used by scripts' GUIs.
	StatusGui	: TextLabel,											-- Reference to current label that save/index statuses are shown in.
	PageLength	: number,												-- How many instances SHOULD be shown on list pages. (Not used by API.)
	AntiLagInterval : number,											-- How many instances to parse before waiting, to reduce lag.
	ClassData	: {ClassDefinition}									-- This script's "Roblox class API" (read-only).
}
local Recreator : ModelRecreatorStruct = env.XRecreator	-- Let's simplify references to the API by just defining a new "shortcut" variable.

local ScriptName		= "Recreator API: "

-- SERVICES
local Players			= game:GetService("Players")	-- These are the three locations that can be accessed using this script.
local Lighting			= game:GetService("Lighting")
local ReplicatedStorage	= game:GetService("ReplicatedStorage")
local ServerStorage		= game:GetService("ServerStorage")	-- This container stores the four "container imposter" Models for redirection.
local MaterialService	= game:GetService("MaterialService")
local StarterGui		= game:GetService("StarterGui")
local SoundService		= game:GetService("SoundService")
local StarterPack		= game:GetService("StarterPack")
local HttpService		= game:GetService("HttpService")
-- REFERENCES (PARTIAL, NOT INCLUDING GUI)
local PlayerGui			= Players.LocalPlayer:WaitForChild("PlayerGui")

-- STATIC DATA

-- STATIC DATA & FUNCTIONS
-- Arrays of properties shared by multiple classes, used to simplify the main class data array/list below.
-- If any list contains a property starting with "UseCmnList_", the script should iterate through the array named after its value here.
local CommonPropList					= {
	Instance							= {
		Name							= "string",
		Parent							= "Instance"
	},
	Attachment							= {
		Axis							= "Vector3",
		SecondaryAxis					= "Vector3",
		CFrame							= "CFrame",	-- Set the CFrame last, in case the previous properties are redundant.
		Visible							= "boolean"
	},
	Decal								= {
		Color3							= "Color3",
		Face							= "EnumItem",	-- Inherited from FaceInstance class
		LocalTransparencyModifier		= "number",
		Texture							= "string",
		Transparency					= "number",
		ZIndex							= "number"
	},
	Model								= {
		LevelOfDetail					= "EnumItem",
		ModelStreamingMode				= "EnumItem",
		PrimaryPart						= "Instance"
	},
	BasePart							= {
		Anchored						= "boolean",
		BackSurface						= "EnumItem",
		BottomSurface					= "EnumItem",
		CFrame							= "CFrame",
		CanCollide						= "boolean",
		CanQuery						= "boolean",
		CanTouch						= "boolean",
		CastShadow						= "boolean",
		CollisionGroup					= "string",
		Color							= "Color3",
		EnableFluidForces				= "boolean",
		FrontSurface					= "EnumItem",
		LeftSurface						= "EnumItem",
		LocalTransparencyModifier		= "number",
		Locked							= "boolean",
		Massless						= "boolean",
		Material						= "EnumItem",
		MaterialVariant					= "string",
		PivotOffset						= "CFrame",
		Reflectance						= "number",
		RightSurface					= "EnumItem",
		RootPriority					= "number",
		Size							= "Vector3",
		TopSurface						= "EnumItem",
		Transparency					= "number"
	},
	Constraint							= {
		Attachment0						= "Instance",
		Attachment1						= "Instance",
		Color							= "BrickColor",
		Enabled							= "boolean",
		Visible							= "boolean"
	},
	JointInstance						= {
		C0								= "CFrame",
		C1								= "CFrame",
		Enabled							= "boolean",
		Part0							= "Instance",
		Part1							= "Instance"
	},
	Light								= {
		Brightness						= "number",
		Color							= "Color3",
		Enabled							= "boolean",
		Shadows							= "boolean"
	},
	Motor								= {
		CurrentAngle					= "number",
		DesiredAngle					= "number",
		MaxVelocity						= "number"
	},
	SpotAndSurfaceLight					= {
		Angle							= "number",
		Face							= "EnumItem",
		Range							= "number"
	},
	SurfaceGuiBase						= {
		Active							= "boolean",
		Adornee							= "Instance",
		Face							= "EnumItem",
	},
	BaseWrap							= {
		CageMeshId						= "string",
		CageOrigin						= "CFrame",
		ImportOrigin					= "CFrame"
	},
	PBRMapSet							= {
		ColorMap						= "string",
		MetalnessMap					= "string",
		NormalMap						= "string",
		RoughnessMap					= "string"
	},
	LayerCollector						= {	-- Used by ScreenGui's and possibly moe classes.
		Enabled							= "boolean",
		ResetOnSpawn					= "boolean",
		ZIndexBehavior					= "EnumItem"
	},
	GuiButton							= {
		AutoButtonColor					= "boolean",
		Modal							= "boolean",
		Selected						= "boolean",
		Style							= "EnumItem"
	},
	GuiObject							= {
		Active							= "boolean",
		AnchorPoint						= "Vector2",
		AutomaticSize					= "EnumItem",
		BackgroundColor3				= "Color3",
		BackgroundTransparency			= "number",
		BorderColor3					= "Color3",
		BorderMode						= "EnumItem",
		BorderSizePixel					= "number",
		ClipsDescendants				= "boolean",
		-- Draggable					= "boolean",
		Interactable					= "boolean",
		LayoutOrder						= "number",
		Position						= "UDim2",
		Rotation						= "number",
		Selectable						= "boolean",
		SelectionOrder					= "number",
		Size							= "UDim2",
		SizeConstraint					= "EnumItem",
		Visible							= "boolean",
		ZIndex							= "number"
	},
	GuiBase2d							= {
		AutoLocalize					= "boolean"
	},
	GuiTextElement						= {	-- TextButtons and TextLabels have the exact same properties!
		FontFace						= "Font",
		LineHeight						= "number",
		MaxVisibleGraphemes				= "number",
		RichText						= "boolean",
		Text							= "string",
		TextColor3						= "Color3",
		TextDirection					= "EnumItem",
		TextScaled						= "boolean",
		TextSize						= "number",
		TextStrokeColor3				= "Color3",
		TextStrokeTransparency			= "number",
		TextTransparency				= "number",
		TextTruncate					= "EnumItem",
		TextWrapped						= "boolean",
		TextXAlignment					= "EnumItem",
		TextYAlignment					= "EnumItem"
	},
	GuiImageElement						= {	-- Properties reused between ImageLabels and ImageButtons.
		Image							= "string",
		ImageColor3						= "Color3",
		ImageRectOffset					= "Vector2",
		ImageRectSize					= "Vector2",
		ImageTransparency				= "number",
		ResampleMode					= "EnumItem",
		ScaleType						= "EnumItem",
		SliceCenter						= "Rect",
		SliceScale						= "number",
		TileSize						= "UDim2"
	},
	UIGridStyleLayout					= {
		FillDirection					= "EnumItem",
		HorizontalAlignment				= "EnumItem",
		SortOrder						= "EnumItem",
		VerticalAlignment				= "EnumItem"
	}
}

-- A very long, complex array of dictionary entries that specifies what properties should be saved for specific instance classes, and what
-- their types are. This may look almost identical to its plugin counterpart, but there are some differences. For example, MeshParts' MeshId
-- property is included in the script version so it saves its value, but it's commented out in the plugin, since modifying that property
-- directly will cause errors and break its functions.

-- When iterating through one of these property lists, make sure it's always done from top to bottom; Sometimes, the properties have to be set
-- out of alphabetical order! Also, Don't use a "UseCmnList_" definition to inherit from the "Instance" list above! The final script will
-- automatically do that to simplify things.

-- When ay reference to an Instance is found by the Studio plugin, just silently add each of the properties to an array index named after the
-- instance's "intended debug ID", then go back through that list afte all instances have been "imported" and use the complete "debug ID" array
-- to link each of the properties to their intended "reconstructed" instances.
env.XRecreator.ClassData				= {
	["AdGui"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📊",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "LayerCollector",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			UseCmnList_3				= "SurfaceGuiBase",
			AdShape						= "EnumItem",
			EnableVideoAds				= "boolean",
			FallbackImage				= "string",
		}
	},
	["Attachment"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔌",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Attachment"	-- Common properties that this class shares with others.
		}
	},
	["Accessory"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "👚",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "child"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			AccessoryType				= "EnumItem",
			AttachmentPoint				= "CFrame"	-- Inherited from Accoutrement (What even is that word?)
		}
	},
	["Animation"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🤺",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			AnimationId					= "string"
		}
	},
	["AnimationController"]				= {	-- AnimationController instances don't have any properties other than standard Instance ones.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🤺",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
		}
	},
	--[[["Animator"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🤺",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			PreferLodEnabled			= "boolean"
		}
	},]]--
	["Atmosphere"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⛅",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Color						= "Color3",
			Decay						= "Color3",
			Density						= "number",
			Glare						= "number",
			Haze						= "number",
			Offset						= "number"
		}
	},
	["Backpack"]						= {	-- Backpacks don't have any properties other than standard Instance ones.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🎒",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
		}
	},
	["Beam"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⚡",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Attachment0					= "Instance",
			Attachment1					= "Instance",
			LightInfluence				= "number",	-- Brightness is only used if LightInfluence is set to a low value.
			Brightness					= "number",
			Color						= "ColorSequence",
			CurveSize0					= "number",
			CurveSize1					= "number",
			Enabled						= "boolean",
			FaceCamera					= "boolean",
			LightEmission				= "number",
			Segments					= "number",
			Texture						= "string",
			TextureLength				= "number",
			TextureMode					= "EnumItem",
			TextureSpeed				= "number",
			Transparency				= "NumberSequence",
			Width0						= "number",
			Width1						= "number",
			ZOffset						= "number"
		}
	},
	["BillboardGui"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🛑",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "LayerCollector",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			Active						= "boolean",
			Adornee						= "Instance",
			AlwaysOnTop					= "boolean",
			Brightness					= "number",
			ClipsDescendants			= "boolean",
			DistanceLowerLimit			= "number",
			DistanceStep				= "number",
			DistanceUpperLimit			= "number",
			ExtentsOffset				= "Vector3",
			ExtentsOffsetWorldSpace		= "Vector3",
			LightInfluence				= "number",
			MaxDistance					= "number",
			Size						= "UDim2",
			SizeOffset					= "Vector2",
			StudsOffset					= "Vector3",
			StudsOffsetWorldSpace		= "Vector3"
		}
	},
	["BloomEffect"]						= {	-- Decals' properties are reused for Textures.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌄",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Enabled						= "boolean",	-- Inherited from PostEffect class
			Intensity					= "number",
			Size						= "number",
			Threshold					= "number"
		}
	},
	["BlurEffect"]						= {	-- Decals' properties are reused for Textures.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌄",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Enabled						= "boolean",	-- Inherited from PostEffect class
			Size						= "number",
		}
	},
	["Bone"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🦴",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Attachment",	-- Common properties that this class shares with others.
			Transform					= "CFrame"
		}
	},
	["BoolValue"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "boolean"
		}
	},
	["BrickColorValue"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "BrickColor"
		}
	},
	["Camera"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🎥",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Cameras aren't used much outside of ViewportFrames so I don't want to script viewing them.
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			CameraType					= "EnumItem",
			CameraSubject				= "Instance",
			FieldOfViewMode				= "EnumItem",
			DiagonalFieldOfView			= "number",
			MaxAxisFieldOfView			= "number",
			FieldOfView					= "number",
			Focus						= "CFrame",
			HeadLocked					= "boolean",
			HeadScale					= "number",
			VRTiltAndRollEnabled		= "boolean",
			CFrame						= "CFrame"
		}
	},
	["CanvasGroup"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🏢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiObject",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			GroupColor3					= "Color3",
			GroupTransparency			= "number"
		}
	},
	["CFrameValue"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "CFrame"
		}
	},
	["Color3Value"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "Color3"
		}
	},
	["ColorCorrectionEffect"]			= {	-- Decals' properties are reused for Textures.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌄",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Enabled						= "boolean",	-- Inherited from PostEffect class
			Brightness					= "number",
			Contrast					= "number",
			Saturation					= "number",
			TintColor					= "Color3"
		}
	},
	["Configuration"]					= {	-- Configuration folders don't have any properties other than standard Instance ones.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⚙",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
		}
	},
	["CornerWedgePart"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧱",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart"	-- Use all of the properties shared by all BasePart instances.
		}
	},
	["Decal"]							= {	-- Decals' properties are reused for Textures.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📄",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Decal",	-- Common properties that this class shares with others.
		}
	},
	["DepthOfFieldEffect"]						= {	-- Decals' properties are reused for Textures.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌄",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Enabled						= "boolean",	-- Inherited from PostEffect class
			FarIntensity				= "number",
			FocusDistance				= "number",
			InFocusRadius				= "number",
			NearIntensity				= "number"
		}
	},
	["DoubleConstrainedValue"]			= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			MaxValue					= "number",
			MinValue					= "number"
		}
	},
	["Fire"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔥",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Color						= "Color3",
			Enabled						= "boolean",
			Heat						= "number",
			SecondaryColor				= "Color3",
			Size						= "number",
			TimeScale					= "number"
		}
	},
	["Folder"]							= {	-- Folders don't have any properties other than standard Instance ones.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📁",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
		}
	},
	["Frame"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🖼",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiObject",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			Style						= "EnumItem"
		}
	},
	["Highlight"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔳",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Adornee						= "Instance",
			DepthMode					= "EnumItem",
			Enabled						= "boolean",
			FillColor					= "Color3",
			FillTransparency			= "number",
			OutlineColor				= "Color3",
			OutlineTransparency			= "number"
		}
	},
	["HingeConstraint"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧷",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint",	-- Common properties that this class shares with others.
			ActuatorType				= "EnumItem",
			AngularResponsiveness		= "number",
			AngularVelocity				= "number",
			LimitsEnabled				= "boolean",
			LowerAngle					= "number",
			MotorMaxAcceleration		= "number",
			MotorMaxTorque				= "number",
			Radius						= "number",
			Restitution					= "number",
			ServoMaxTorque				= "number",
			TargetAngle					= "number",
			UpperAngle					= "number"
		}
	},
	["Humanoid"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🙍🏼‍",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			AutoJumpEnabled				= "boolean",
			AutoRotate					= "boolean",
			AutomaticScalingEnabled		= "boolean",
			BreakJointsOnDeath			= "boolean",
			CameraOffset				= "Vector3",
			DisplayDistanceType			= "EnumItem",
			DisplayName					= "string",
			-- EvaluateStateMachine		= "boolean",
			Health						= "number",
			HealthDisplayDistance		= "number",
			HealthDisplayType			= "EnumItem",
			HipHeight					= "number",
			JumpHeight					= "number",
			JumpPower					= "number",
			MaxHealth					= "number",
			MaxSlopeAngle				= "number",
			NameDisplayDistance			= "number",
			NameOcclusion				= "EnumItem",
			PlatformStand				= "boolean",
			RequiresNeck				= "boolean",
			RigType						= "EnumItem",	-- Should this property be captured?
			UseJumpPower				= "boolean",
			WalkSpeed					= "number"
		}
	},
	["HumanoidDescription"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "👤",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			BackAccessory				= "string",
			BodyTypeScale				= "number",
			ClimbAnimation				= "number",
			DepthScale					= "number",
			Face						= "number",
			FaceAccessory				= "string",
			FallAnimation				= "number",
			FrontAccessory				= "string",
			GraphicTShirt				= "number",
			HairAccessory				= "string",
			HatAccessory				= "string",
			Head						= "number",
			HeadColor					= "Color3",
			HeadScale					= "number",
			HeightScale					= "number",
			IdleAnimation				= "number",
			JumpAnimation				= "number",
			LeftArm						= "number",
			LeftArmColor				= "Color3",
			LeftLeg						= "number",
			LeftLegColor				= "Color3",
			MoodAnimation				= "number",
			NeckAccessory				= "string",
			Pants						= "number",
			ProportionScale				= "number",
			RightArm					= "number",
			RightArmColor				= "Color3",
			RightLeg					= "number",
			RightLegColor				= "Color3",
			RunAnimation				= "number",
			Shirt						= "number",
			ShouldersAccessory			= "string",
			SwimAnimation				= "number",
			Torso						= "number",
			TorsoColor					= "Color3",
			WaistAccessory				= "string",
			WalkAnimation				= "number",
			WidthScale					= "number"
		}
	},
	["ImageButton"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🏞",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiImageElement",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiButton",
			UseCmnList_3				= "GuiObject",
			UseCmnList_4				= "GuiBase2d",
			HoverImage					= "string",
			PressedImage				= "string"
		}
	},
	["ImageLabel"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🏞",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiImageElement",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiObject",
			UseCmnList_3				= "GuiBase2d"
		}
	},
	["IntValue"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "number"
		}
	},
	["IntConstrainedValue"]				= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			MaxValue					= "number",
			MinValue					= "number"
		}
	},
	["LineForce"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "↗",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint",	-- Common properties that this class shares with others.
			ApplyAtCenterOfMass			= "boolean",
			InverseSquareLaw			= "boolean",
			Magnitude					= "number",
			MaxForce					= "number",
			ReactionForceEnabled		= "boolean"
		}
	},
	["MaterialVariant"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🏁",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "PBRMapSet",	-- Common properties that this class shares with others.
			BaseMaterial				= "EnumItem",
			CustomPhysicalProperties	= "PhysicalProperties",
			MaterialPattern				= "EnumItem",
			StudsPerTile				= "number",
		}
	},
	["MeshPart"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧭",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart",	-- Use all of the properties shared by all BasePart instances.
			DoubleSided					= "boolean",
			TextureID					= "string",
			MeshId						= "string",	-- Comment this line out in the plugin! MeshIds can't be set directly, only used on creation.
			RenderFidelity				= "EnumItem",	-- Comment this out too...
			CollisionFidelity			= "EnumItem"	-- ...and this one! (This inherits from the "TriangleMeshPart" class, also used by unions.)
		}
	},
	["Model"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔳",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Model"	-- Other classes inherit from this one.
		}
	},
	["Motor"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🛵",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Motor",
			UseCmnList_2				= "JointInstance"
		}
	},
	["Motor6D"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "💪🏼",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Motor",
			UseCmnList_2				= "JointInstance",
			Transform					= "CFrame"
		}
	},
	["NumberValue"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "number"
		}
	},
	["ObjectValue"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "Instance"
		}
	},
	["Pants"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "👕",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			PantsTemplate				= "string",
			Color3						= "Color3"	-- Inherited from Clothing class
		}
	},
	["Part"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧱",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart",	-- Use all of the properties shared by all BasePart instances.
			Shape						= "EnumItem"
		}
	},
	["ParticleEmitter"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "✨",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Acceleration				= "Vector3",
			LightInfluence				= "number",	-- Brightness is only used if LightInfluence is set to a low value.
			Brightness					= "number",
			Color						= "ColorSequence",
			Drag						= "number",
			EmissionDirection			= "EnumItem",
			Enabled						= "boolean",
			FlipbookFramerate			= "NumberRange",
			FlipbookIncompatible		= "string",
			FlipbookLayout				= "EnumItem",
			FlipbookMode				= "EnumItem",
			FlipbookStartRandom			= "boolean",
			Lifetime					= "NumberRange",
			LightEmission				= "number",
			LockedToPart				= "boolean",
			Orientation					= "EnumItem",
			Rate						= "number",
			RotSpeed					= "NumberRange",
			Rotation					= "NumberRange",
			Shape						= "EnumItem",
			ShapeInOut					= "EnumItem",
			ShapePartial				= "number",
			ShapeStyle					= "EnumItem",
			Size						= "NumberSequence",
			Speed						= "NumberRange",
			SpreadAngle					= "Vector2",
			Squash						= "NumberSequence",
			Texture						= "string",
			TimeScale					= "number",
			Transparency				= "NumberSequence",
			VelocityInheritance			= "number",
			WindAffectsDrag				= "boolean",
			ZOffset						= "number"
		}
	},
	["PlaneConstraint"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧷",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint"	-- Common properties that this class shares with others.
		}
	},
	["Player"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "👤",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			AutoJumpEnabled				= "boolean",
			CameraMaxZoomDistance		= "number",
			CameraMinZoomDistance		= "number",
			CameraMode					= "EnumItem",
			CanLoadCharacterAppearance	= "boolean",
			Character					= "Instance",
			CharacterAppearanceId		= "number",
			DevCameraOcclusionMode		= "EnumItem",
			DevComputerCameraMode		= "EnumItem",
			DevComputerMovementMode		= "EnumItem",
			DevEnableMouseLock			= "boolean",
			DevTouchCameraMode			= "EnumItem",
			DevTouchMovementMode		= "EnumItem",
			DisplayName					= "string",
			HealthDisplayDistance		= "number",
			NameDisplayDistance			= "number",
			Neutral						= "boolean",
			-- ReplicationFocus			= "Instance",
			-- RespawnLocation			= "Instance",
			-- Team						= "Instance",
			TeamColor					= "BrickColor",
			UserId						= "number"
		}
	},
	["PlayerGui"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📱",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			ScreenOrientation			= "EnumItem",
		}
	},
	["PointLight"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "💡",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Light",	-- Common properties that this class shares with others.
			Range						= "number"
		}
	},
	["PrismaticConstraint"]				= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧷",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "SlidingBallConstraint",	-- Common properties that this class shares with others.
			UseCmnList_2				= "Constraint"
		}
	},
	["RodConstraint"]				= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧷",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint",	-- Common properties that this class shares with others.
			Length						= "boolean",
			LimitAngle0					= "number",
			LimitAngle1					= "number",
			LimitsEnabled				= "boolean",
			Thickness					= "number"
		}
	},
	["RopeConstraint"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧷",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint",	-- Common properties that this class shares with others.
			Length						= "number",
			Restitution					= "number",
			Thickness					= "number",
			WinchEnabled				= "boolean",
			WinchForce					= "number",
			WinchResponsiveness			= "number",
			WinchSpeed					= "number",
			WinchTarget					= "number"
		}
	},
	["ScreenGui"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📱",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "LayerCollector",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			ClipToDeviceSafeArea		= "boolean",
			DisplayOrder				= "number",
			IgnoreGuiInset				= "boolean",
			SafeAreaCompatibility		= "EnumItem",
			ScreenInsets				= "EnumItem"
		}
	},
	["ScrollingFrame"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🖼",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiObject",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			AutomaticCanvasSize			= "EnumItem",
			BottomImage					= "string",
			CanvasPosition				= "Vector2",
			CanvasSize					= "UDim2",
			ElasticBehavior				= "EnumItem",
			HorizontalScrollBarInset	= "EnumItem",
			MidImage					= "string",
			ScrollBarImageColor3		= "Color3",
			ScrollBarImageTransparency	= "number",
			ScrollBarThickness			= "number",
			ScrollingDirection			= "EnumItem",
			ScrollingEnabled			= "boolean",
			TopImage					= "string",
			VerticalScrollBarInset		= "EnumItem",
			VerticalScrollBarPosition	= "EnumItem"
		}
	},
	["Seat"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🪑",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart",	-- Use all of the properties shared by all BasePart instances.
			Shape						= "EnumItem",	-- Inherited from Part class
			Disabled					= "boolean"
		}
	},
	["Shirt"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "👕",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			ShirtTemplate				= "string",
			Color3						= "Color3"	-- Inherited from Clothing class
		}
	},
	["ShirtGraphic"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🎽",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Graphic						= "string",
			Color3						= "Color3"
		}
	},
	["Sky"]								= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌄",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			CelestialBodiesShown		= "boolean",
			MoonAngularSize				= "number",
			MoonTextureId				= "string",
			SkyboxBk					= "string",
			SkyboxDn					= "string",
			SkyboxFt					= "string",
			SkyboxLf					= "string",
			SkyboxRt					= "string",
			SkyboxUp					= "string",
			StarCount					= "number",
			SunAngularSize				= "number",
			SunTextureId				= "string"
		}
	},
	["Smoke"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "☁",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Color						= "Color3",
			Enabled						= "boolean",
			Opacity						= "number",
			RiseVelocity				= "number",
			Size						= "number",
			TimeScale					= "number"
		}
	},
	["Sparkles"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "✨",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Color						= "Color3",
			Enabled						= "boolean",
			SparkleColor				= "Color3",
			TimeScale					= "number"
		}
	},
	["SpawnLocation"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌌",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart",	-- Use all of the properties shared by all BasePart instances.
			Shape						= "EnumItem",	-- Inherited from Part class
			AllowTeamChangeOnTouch		= "boolean",
			Duration					= "number",
			Enabled						= "boolean",
			Neutral						= "boolean",
			TeamColor					= "BrickColor"
		}
	},
	["SpecialMesh"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🥘",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			MeshType					= "EnumItem",
			MeshId						= "string",		-- Inherited from FileMesh
			TextureId					= "string",		-- Inherited from FileMesh
			Offset						= "Vector3",	-- Inherited from DataModelMesh
			Scale						= "Vector3",	-- Inherited from DataModelMesh
			VertexColor					= "Vector3"		-- Inherited from DataModelMesh
		}
	},
	["SpotLight"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "💡",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Light",	-- Common properties that this class shares with others.
			UseCmnList_2				= "SpotAndSurfaceLight"
		}
	},
	["SpringConstraint"]				= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧷",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint",	-- Common properties that this class shares with others.
			Coils						= "number",
			Damping						= "number",
			FreeLength					= "number",
			LimitsEnabled				= "boolean",
			MaxForce					= "number",
			MaxLength					= "number",
			MinLength					= "number",
			Radius						= "number",
			Stiffness					= "number",
			Thickness					= "number"
		}
	},
	["StringValue"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "string"
		}
	},
	["SunRaysEffect"]					= {	-- Decals' properties are reused for Textures.
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌞",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Enabled						= "boolean",	-- Inherited from PostEffect class
			Intensity					= "number",
			Spread						= "number"
		}
	},
	["SurfaceAppearance"]				= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🏐",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "PBRMapSet",	-- Common properties that this class shares with others.
			AlphaMode					= "EnumItem",
		}
	},
	["SurfaceGui"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌘",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "LayerCollector",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			UseCmnList_3				= "SurfaceGuiBase",
			AlwaysOnTop					= "boolean",
			Brightness					= "number",
			CanvasSize					= "Vector2",
			ClipsDescendants			= "boolean",
			LightInfluence				= "number",
			MaxDistance					= "number",
			PixelsPerStud				= "number",
			SizingMode					= "EnumItem",
			ToolPunchThroughDistance	= "number",
			ZOffset						= "number"
		}
	},
	["SurfaceLight"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "💡",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Light",	-- Common properties that this class shares with others.
			UseCmnList_2				= "SpotAndSurfaceLight"
		}
	},
	["TextBox"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🖊",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiTextElement",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiObject",
			UseCmnList_3				= "GuiBase2d",
			ClearTextOnFocus			= "boolean",
			-- CursorPosition				= "number",
			MultiLine					= "boolean",
			PlaceholderColor3			= "Color3",
			PlaceholderText				= "string",
			-- SelectionStart				= "number",
			ShowNativeInput				= "boolean",
			TextEditable				= "boolean"
		}
	},
	["TextButton"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔠",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiTextElement",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiButton",
			UseCmnList_3				= "GuiObject",
			UseCmnList_4				= "GuiBase2d"
		}
	},
	["TextLabel"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔠",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiTextElement",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiObject",
			UseCmnList_3				= "GuiBase2d"
		}
	},
	["Texture"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📄",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Decal",	-- Common properties that this class shares with others.
			OffsetStudsU				= "number",
			OffsetStudsV				= "number",
			StudsPerTileU				= "number",
			StudsPerTileV				= "number"
		}
	},
	["Tool"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🛠",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "child"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Model",	-- Common properties that this class shares with others.
			CanBeDropped				= "boolean",
			Enabled						= "boolean",
			Grip						= "CFrame",
			ManualActivationOnly		= "boolean",
			RequiresHandle				= "boolean",
			ToolTip						= "string",
			TextureId					= "string"	-- Inherited from BackpackItem
		}
	},
	["Trail"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🎗",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "parent"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Attachment0					= "Instance",
			Attachment1					= "Instance",
			LightInfluence				= "number",	-- Brightness is only used if LightInfluence is set to a low value.
			Brightness					= "number",
			Color						= "ColorSequence",
			Enabled						= "boolean",
			FaceCamera					= "boolean",
			Lifetime					= "number",
			LightEmission				= "number",
			MaxLength					= "number",
			MinLength					= "number",
			Texture						= "string",
			TextureLength				= "number",
			TextureMode					= "EnumItem",
			Transparency				= "number",
			WidthScale					= "NumberSequence"
		}
	},
	["TrussPart"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "💈",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart",	-- Use all of the properties shared by all BasePart instances.
			Style						= "EnumItem"
		}
	},
	["UIAspectRatioConstraint"]			= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			AspectRatio					= "number",
			AspectType					= "EnumItem",
			DominantAxis				= "EnumItem"
		}
	},
	["UICorner"]			= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			CornerRadius				= "UDim"
		}
	},
	["UIFlexItem"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔛",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			FlexMode					= "EnumItem",
			GrowRatio					= "number",
			ItemLineAlignment			= "EnumItem",
			ShrinkRatio					= "number"
		}
	},
	["UIGradient"]			= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🎨",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Color						= "ColorSequence",
			Enabled						= "boolean",
			Offset						= "Vector2",
			Rotation					= "number",
			Transparency				= "NumberSequence"
		}
	},
	["UIGridLayout"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no",	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "UIGridStyleLayout",
			CellPadding					= "UDim2",
			CellSize					= "UDim2",
			FillDirectionMaxCells		= "number",
			StartCorner					= "EnumItem"
		}
	},
	["UIListLayout"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "UIGridStyleLayout",
			HorizontalFlex				= "EnumItem",
			ItemLineAlignment			= "EnumItem",
			Padding						= "UDim",
			VerticalFlex				= "EnumItem",
			Wraps						= "boolean"
		}
	},
	["UIPadding"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "◻",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			PaddingBottom				= "UDim",
			PaddingLeft					= "UDim",
			PaddingRight				= "UDim",
			PaddingTop					= "UDim"
		}
	},
	["UIPageLayout"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no",	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "UIGridStyleLayout",
			Animated					= "boolean",
			Circular					= "boolean",
			EasingDirection				= "EnumItem",
			EasingStyle					= "EnumItem",
			GamepadInputEnabled			= "boolean",
			Padding						= "UDim",
			ScrollWheelInputEnabled		= "boolean",
			TouchInputEnabled			= "boolean",
			TweenTime					= "number"
		}
	},
	["UIScale"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "↗",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Scale						= "number"
		}
	},
	["UISizeConstraint"]			= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			MaxSize						= "Vector2",
			MinSize						= "Vector2"
		}
	},
	["UIStroke"]			= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🖇",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			ApplyStrokeMode				= "EnumItem",
			Color						= "Color3",
			Enabled						= "boolean",
			LineJoinMode				= "EnumItem",
			Thickness					= "number",
			Transparency				= "number"
		}
	},
	["UITableLayout"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no",	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "UIGridStyleLayout",
			FillEmptySpaceColumns		= "boolean",
			FillEmptySpaceRows			= "boolean",
			MajorAxis					= "EnumItem",
			Padding						= "UDim2"
		}
	},
	["UITextSizeConstraint"]			= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "⏹",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			MaxTextSize						= "number",
			MinTextSize						= "number"
		}
	},
	["UniversalConstraint"]				= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧷",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint",	-- Common properties that this class shares with others.
			LimitsEnabled				= "boolean",
			MaxAngle					= "number",
			Radius						= "number",
			Restitution					= "number"
		}
	},
	["Vector3Value"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔢",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			Value						= "Vector3"
		}
	},
	["VectorForce"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "↗",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Constraint",	-- Common properties that this class shares with others.
			ApplyAtCenterOfMass			= "boolean",
			Force						= "Vector3",
			RelativeTo					= "EnumItem"
		}
	},
	["VehicleSeat"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🚗",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart",	-- Use all of the properties shared by all BasePart instances.
			Disabled					= "boolean",
			HeadsUpDisplay				= "boolean",
			MaxSpeed					= "number",
			Torque						= "number",
			TurnSpeed					= "number"
		}
	},
	["ViewportFrame"]					= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📊",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "GuiObject",	-- Common properties that this class shares with others.
			UseCmnList_2				= "GuiBase2d",
			Ambient						= "Color3",
			CurrentCamera				= "Instance",
			ImageColor3					= "Color3",
			ImageTransparency			= "number",
			LightColor					= "Color3",
			LightDirection				= "Vector3"
		}
	},
	["WedgePart"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🧱",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "yes"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BasePart"	-- Use all of the properties shared by all BasePart instances.
		}
	},
	["Weld"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🔗",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= true,	-- Create an Instance of this type when testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "JointInstance"
		}
	},
	["WorldModel"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌎",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "Model"	-- Common properties that this class shares with others.
		}
	},
	["WrapLayer"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "↔",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BaseWrap",	-- Common properties that this class shares with others.
			AutoSkin					= "EnumItem",
			BindOffset					= "CFrame",
			Enabled						= "boolean",
			Order						= "number",
			Puffiness					= "number",
			ReferenceMeshId				= "string",
			ReferenceOrigin				= "CFrame",
			ShrinkFactor				= "number"
		}
	},
	["WrapTarget"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "↔",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		},
		Props							= {		-- List of properties that should be saved or loaded to/from JSON for this instance.
			UseCmnList_1				= "BaseWrap",	-- Common properties that this class shares with others.
			Stiffness					= "number"
		}
	},

	-- The four Instance classes below are only ever displayed in the list, never exported or imported, so they're intentionally folder-like.
	["Workspace"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌎",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		}
	},
	["Players"]							= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "👥",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		}
	},
	["Lighting"]						= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "🌤",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		}
	},
	["ReplicatedStorage"]				= {
		ListView						= {		-- Properties that customize how this instance is displayed in the list (only used in the script).
			Icon						= "📦",	-- Emoji used to represent this instance when it's unselected.
			CreateTest					= false,	-- Don't attempt to make an Instance of this type if testing the script in Roblox Studio.
			CanView						= "no"	-- Can the camera focus on this instance?
		}
	},
}
table.freeze(Recreator.ClassData)	-- The table above is read-only; Nothing can or should mess it up.
print("✅Imported packaged Roblox class API...")

-- COLORSEQUENCE & NUMBERSEQUENCE FUNCTIONS (COPIED FROM MY PARSING UTILITY)
-- Iterates through the provided array of strings and makes sure all items can be converted into numbers.
local function ContainsOnlyNumbers(_list : {string})
	local success = false	-- Assume failure by default.

	-- Make sure the list exists, is an array, contains at least one item, and the first item is a string.
	if _list and type(_list) == "table" and #_list > 0 and type(_list[1]) == "string" then
		for _, item in _list do
			if tonumber(item) then success = true	-- if any number is found, it is treated as a "success", but if a non-number is found, this becomes false.
			else	-- Did you find something that isn't a number in the list? Stop iterating and say that this is a failure.
				print(item, "isn't a number.")
				success = false
				break
			end
		end
	end

	return success
end

-- GetSequenceType (takes array of strings and a string, returns string)
-- Does various checks on the given list of numbers (in string form) to decide if it could be a NumberSequence or ColorSequence.
local function GetSequenceType(_seq : {string}, _fallback : string) : string?
	-- A string noting what type of sequence that the passed sequence of strings is. It becomes "number" or "color" in most cases.
	-- In the event neither type is detected, the "fallback" type passed to this function is used instead.
	local GuessedType = _fallback
	local FilteredLists = {		-- Filtered versions of the "sequence" which only contain every 5th and 3rd entry, respectively, used for the last verify step.
		ColorSeq = {},
		NumberSeq = {}
	}

	-- Detection flags, used when the filtered lists are iterated through. If all numbers in a given list are zeroes, the cooresponding flag here will be TRUE.
	local IsNumberSequence = true
	local IsColorSequence = true

	-- Catch if the "list" isn't actually an array, or if the values within it somehow aren't strings. If it meets either of those criteria, reject it.
	-- Unlike in this function's origins, this returns nil instead of "none" here, which is simpler to check for (if not [variable]).
	if not ContainsOnlyNumbers(_seq) then return nil end
	if type(_seq) ~= "table" then return nil
	elseif type(_seq[1]) ~= "string" then return nil
	end

	-- Add every 3rd and 5th number to the "filtered" lists. These can be used to identify a list's type, but can't really be trusted
	-- because NumberSequences' 3rd numbers aren't always 0; Those are actually used for its "envelope" values!
	for i, value in _seq do
		if i % 3 == 0 then table.insert(FilteredLists.NumberSeq, value)	-- NumberSequences use multiples of 3 numbers.
		elseif i % 5 == 0 then table.insert(FilteredLists.ColorSeq, value)	-- ColorSequences use multiples of 5 numbers.
		end
	end

	-- Though it's really unoptimal, and shouldn't be done this way if this was, say, code for Project Magical Mary,
	-- let's check both filtered lists and see if they're filled with zeroes. If any non-zero number is found, immediately break the loop.
	-- Also, if the list doesn't contain a multiple of 3 or 5 numbers, it can't be a number or color sequence, respectively.
	if #_seq % 5 == 0 then
		for _, value in FilteredLists.ColorSeq do
			if value ~= "0" then
				IsColorSequence = false	-- This can't be a ColorSequence. Skip the rest of the list!
				break
			end
		end
	else IsColorSequence = false	-- ColorSequences always have a multiple of five numbers.
	end

	if #_seq % 3 == 0 then
		for _, value in FilteredLists.NumberSeq do
			if not tonumber(value) then	-- If this value can't be converted into a number, this can't be any kind of sequence!
				IsColorSequence = false
				IsNumberSequence = false	-- This can't be a NumberSequence. Skip the rest of the list!
				break
			elseif tonumber(value) < 0 or tonumber(value) > 1 then	-- Envelopes are within a 0-1 range inclusively.
				IsNumberSequence = false
				break
			end
		end
	else IsNumberSequence = false	-- NumberSequences always have a multiple of three numbers.
	end

	if IsNumberSequence then GuessedType = "number"
	elseif IsColorSequence then GuessedType = "color"
	end

	return GuessedType	-- Return whatever type that the sequenced was guessed to be. If it wasn't confirmed, this will use whatever the default was.
end

-- The main sequence-parsing function, ported and modified from my parsing utility! It tries to make sense of a series of numbers
-- separated by single spaces, converting it back into a ColorSequence or NumberSequence. If a sequence contains 5 colors or 3
-- numeric values, it's ambiguous, and it's vital that any valid sequence is imported as the exact type Roblox expects for a given
-- property. If the script can't tell for sure, it'll blindly assume it's the type given as the second parameter.

-- As long as nothing unexpected makes this function throw an error while executing, it will return two values (like a pcall), a
-- boolean, which is TRUE if a seqeunce was created successfully) and either a string (for errors) or the sequence, if it passes!
local function ParseSequence(_sequence : string, _type : string) : (boolean, string|ColorSequence|NumberSequence)
	-- First, see if anything actually was inputted, and if there aren't any trailing spaces.
	local SeemsValid = false	-- This is set to TRUE if the text passes these checks.
	
	if _sequence:len() > 0 then
		if _sequence:sub(1,1) ~= " " then
			if _sequence:sub(-1,-1) ~= " " then
				if _sequence:find(" ") then
					SeemsValid = true	-- Hmm, this seems like a legitimate sequence. Let's continue!
				else return false, "This isn't a number sequence. No spaces were found!"
				end
			else return false, "There was a space after the sequence of numbers (normally impossible)."
			end
		else return false, "There was a space before the sequence began (normally impossible)."
		end
	else return false, "Somehow, the sequence didn't contain any text."
	end
	
	if SeemsValid then
		-- Split the sequence into items on each space.
		local NumList = _sequence:split(" ")
		
		-- An array of keypoints, used to make the complete ColorSequence/NumberSequence at the end of this function.
		local KeypointCollection : {ColorSequenceKeypoint}|{NumberSequenceKeypoint} = {}
		-- print("Array contents:", NumList)
		if type(NumList) == "table" and #NumList > 1 then
			local DetectedType = GetSequenceType(NumList, _type)
			-- print(temp_sequenceType)
			
			-- Cool, it's a valid sequence, so parsing can begin. The detected sequence type is only checked to stop invalid sequences from passing.
			if DetectedType then
				-- Write the header section of the parser's output.
				local temp_output = ""
				local item_multiple = 3	-- During the for loop, only one every "X" items are processed.
				if _type == "color" then
					-- temp_output = "This is a ColorSequence with " .. #NumList / 5 .. " points.\u{000D}\u{000A}\u{000D}\u{000A}"
					item_multiple = 5
				-- else temp_output = "This is a NumberSequence with " .. #NumList / 3 .. " points.\u{000D}\u{000A}\u{000D}\u{000A}"
				end
				
				-- If the sequence contains 21 or more points, fail immediately with a warning. Otheerwise, proceed to parsing the string.
				if #NumList / item_multiple <= 20 then
					-- Next, advance through each item in the array, assuming that each number represents what it's meant to.
					-- For both kinds of sequences, the first value is always the "position" or "alpha" or the point on the graph in Studio.
					-- In ColorSequences, the next 3 values are the RGB components of a Color3, while there's only 1 value for NumberSequences, its numerical value.
					-- For some reason, the next number is always zero, and I don't know why Roblox added this padding between each point.
					local ZeroMissing = false	-- If a useless zero used for padding isn't found, parsing fails on the spot.
					for i = 1,	#NumList do
						if i == 1 or i % item_multiple == 1 then
							-- print("Now parsing point #", (i/item_multiple)+1, ", array index", i)
							-- temp_output = temp_output .. "POINT " .. math.floor(i / item_multiple)+1 .. "/" .. #NumList / item_multiple .. "\u{000D}\u{000A}"
							-- temp_output = temp_output .. "Position: " .. NumList[i] .. "\u{000D}\u{000A}"
							if _type == "color" then
								-- print("Color should start at index", i+1, "and its RGB values should be", NumList[i+1], NumList[i+2], "and", NumList[i+3])
								local temp_newKeypoint = ColorSequenceKeypoint.new(
									math.clamp(tonumber(NumList[i]), 0.0, 1.0),	-- Limit the "point's position"/alpha to its intended range of zero to one.
									Color3.new(tonumber(NumList[i+1]), tonumber(NumList[i+2]), tonumber(NumList[i+3]))
								)
								table.insert(KeypointCollection, temp_newKeypoint)	-- Add this keypoint to the list.
								-- temp_output = temp_output .. "Color: " .. NumList[i+1] .. ", " .. NumList[i+2] .. ", " .. NumList[i+3] ..
								-- 	"\u{000D}\u{000A}\u{000D}\u{000A}"
							else
								-- NumberSequence values are interpreted as greyscale colors, from black to white. This way, the player doesn't see empty space
								-- instead of a gradient. Values above 1 will show up as pure white.
								local temp_newKeypoint = NumberSequenceKeypoint.new(	-- Use all three values for this new keypoint.
									tonumber(NumList[i]), tonumber(NumList[i+1]), tonumber(NumList[i+2])
								)
								table.insert(KeypointCollection, temp_newKeypoint)	-- Add this keypoint to the list.
								-- If this array index is in bounds, display its contents directly, otherwise writing an error message in output.
								local temp_valueForOutput = if NumList[i+1] then NumList[i+1] else "index out of bounds (may be a malformed NumberSequence string)"
								local temp_envelopeForOutput = if NumList[i+2] then NumList[i+2] else "index out of bounds (may be a malformed NumberSequence string)"
								temp_output = temp_output .. "Value: " .. temp_valueForOutput .. "\u{000D}\u{000A}" ..
									"Envelope: " .. temp_envelopeForOutput .. "\u{000D}\u{000A}\u{000D}\u{000A}"
							end
						end
					end
					-- temp_output = temp_output .. "Parsing done by JoyfulFlowerMary's ColorSequence & NumberSequence String Parser."
					
					-- Make sure the sequence is in the correct, ascending order (in terms of time), then construct the finished sequence!
					local FinalSequence : ColorSequence|NumberSequence = nil
					if KeypointCollection and #KeypointCollection > 0 then
						table.sort(KeypointCollection, function(itemA, itemB)
							return itemA.Time < itemB.Time
						end)
						if _type == "color" then
							FinalSequence = ColorSequence.new(KeypointCollection)
						else
							FinalSequence = NumberSequence.new(KeypointCollection)
						end
					end
					
					return true, FinalSequence	-- The ColorSequence or NumberSequence was successfully converted! Let's return it.
				else	-- If the sequence contains 21 or more points, fail immediately with a warning.
					return false, "Sequence contains too many points (21+)"
				end
			elseif not ContainsOnlyNumbers(NumList) then
				return false, "A sequence included a non-numerical value."
			else
				return false, "Somehow, the sequence value saved for a property wasn't a valid sequence."
			end
		else warn("Somehow, this wasn't actually a valid sequence… What did you do?")
		end
	end
	return false, "Reached end of the parsing function without returning. (Report this to Xane, and remember to give him your capture's JSON files!)"
end

-- A string-indexed array of Instances, linking each to its cooresponding debug ID, which is included in saves and is used to maintain
-- links between each Instance in the capture. While the Recreation API normally doesn't store debug IDs in a list like this (unlike
-- Xane's Model Recreator v3), it unfortunately has to do this for imports, as the new Instances won't share the same debug IDs as
-- the server/place they were saved from.
local DebugIDList : {Instance}			= {}

-- GetValue (takes any and string, returns varied content)
-- Interprets a given value as a specific, previously deserialized variable type, restoring it to its original, intended form.
local function GetValue(_value : any, _type : string)
	-- While the "type" argument is respected in most of this function, if the value provided is nil, it takes priority over everything else.
	if typeof(_value) == "nil"  then
		return nil	-- JSON supports nil values! It writes "null" instead of "nil".
	end
	
	-- Basic variables can be used as-is, safely.
	if _type == "boolean" or _type == "number" or _type == "string" then
		return _value
	elseif _type == "Color3" then
		return Color3.new(_value[1], _value[2], _value[3])
	elseif _type == "BrickColor" then
		return BrickColor.new(_value)
		-- TODO: Oh dear... ColorSequences and NumberSequences can't "just" be imported; Try to modify code from the ColorSequence Parsing Utility
		-- (one of my personal Roblox places/experiences) and use that here to reconstruct the ColorSequence/NumberSequence.
		-- Until this is done, the space-separated number series will always be ignored, returning a default gradient instead!
	elseif _type == "ColorSequence" then
		local success, sequence = ParseSequence(_value, "color")
		-- For some reason, every single sequence that has been included in captures using Feb 2024 builds of the script has included an unnecessary
		-- space after the sequence of numbers, which causes the parsing function to fail early. If this call fails due to an extra space, retry
		-- but with the last character excluded. If it fails at this point, there's no point trying to salvage this gradient...
		-- TODO: Check if the last character in the sequence is a space, and if it is, use string:sub(1,-2) to avoid including it in future strings.
		if not success and sequence:find("space after") then
			success, sequence = ParseSequence(_value:sub(1,-2), "color")
		end
		
		-- Did either of the previous function calls succeed? If so, use the sequence! If not, just generate an ugly placeholder and use that instead.
		if success then return sequence
		else
			warn("Xane's Model Recreator (Plugin) - Couldn't convert a ColorSequence properly!", sequence)
			return ColorSequence.new(Color3.new(1,1,1), Color3.new(0,0,0))
		end
	elseif _type == "NumberSequence" then
		-- Old captures of ParticleEmitters incorrectly save their transparency as a number, so they may fail to import if actual "sequence"
		-- handling code is added to replace these greyscale gradient placeholder "functions".
		-- Does what the comment above says happen? Note any errors that occur when importing ParticleEmitters!
		
		local success, sequence = ParseSequence(_value, "number")
		-- For some reason, every single sequence that has been included in captures using Feb 2024 builds of the script has included an unnecessary
		-- space after the sequence of numbers, which causes the parsing function to fail early. If this call fails due to an extra space, retry
		-- but with the last character excluded. If it fails at this point, there's no point trying to salvage this gradient...
		-- TODO: Check if the last character in the sequence is a space, and if it is, use string:sub(1,-2) to avoid including it in future strings.
		if not success and sequence:find("space after") then
			success, sequence = ParseSequence(_value:sub(1,-2), "number")
		end
		
		-- Did either of the previous function calls succeed? If so, use the sequence! If not, just generate an ugly placeholder and use that instead.
		if success then return sequence
		else
			warn("Xane's Model Recreator (Plugin) - Couldn't convert a NumberSequence properly!", sequence)
			return NumberSequence.new(1, 0)
		end
	elseif _type == "NumberRange" then
		return NumberRange.new(_value[1], _value[2])
	elseif _type == "UDim" then
		return UDim.new(_value[1], _value[2])
	elseif _type == "UDim2" then
		return UDim2.new(_value[1], _value[2], _value[3], _value[4])
	elseif _type == "Rect" then	-- Rects are stored as the minimum Vector2 XY values followed by their "max" counterparts. Use Rect.new([1],[2],[3],[4])!
		return Rect.new(_value[1], _value[2], _value[3], _value[4])
	elseif _type == "Font" then
		if true then	-- not _value[2] or not _value[3] then
			return Font.new(_value[1])
		else	-- If only the font family is defined, just use that. Otherwise, try to fill in the weight and style as needed.
			return Font.new(
				_value[1] or "rbxasset://fonts/families/Arimo.json",
				_value[2] or Enum.FontWeight.Regular,
				_value[3] or Enum.FontStyle.Normal
			)
		end
	elseif _type == "Vector2" then
		return Vector2.new(_value[1], _value[2])
	elseif _type == "Vector3" then
		return Vector3.new(_value[1], _value[2], _value[3])
	elseif _type == "EnumItem" then
		return Enum[_value[1]][_value[2]]
	elseif _type == "CFrame" then
		return CFrame.new(
			_value[1], _value[2], _value[3],
			_value[4], _value[5], _value[6],
			_value[7], _value[8], _value[9],
			_value[10], _value[11], _value[12]
		)
	elseif _type == "Instance" then	-- This tries to match a debug ID to its cooresponding Instance. If one isn't found, it'll return nil.
		local DebugIDMatch : Instance? = nil	-- By default, this function will return nil, but this will become an Instance if a match is found
		for i : string, v : Instance in DebugIDList do	-- Iterate through the debug ID list and try to find this instance's ID within it
			if i == _value then
				DebugIDMatch = v	-- If a match is found, return the Instance associated with the debug ID.
				break
			end
		end
		
		return DebugIDMatch	-- If this instance's debug ID wasn't found, this will store "nil" instead, which should be fine.
	elseif _type == "PhysicalProperties" then
		return PhysicalProperties.new(_value[1], _value[2], _value[3], _value[4], _value[5])
	elseif _type == "Faces" then
		return Faces.new(_value)	-- _value supposedly is a list of NormalId Enum values, which willl hopefully work here.
	end
end

-- StoreValue (takes any and string, returns varied content)
-- Takes an arbitrary value and tries to convert it to a value which could be stored in a JSON dictionary. For
-- most variable types, this just takes its components and splits them up into a basic array.
local function StoreValue(_value : any, _type : string)
	-- While the "type" argument is respected in most of this function, if the value provided is nil, it takes priority over everything else.
	if typeof(_value) == "nil"  then
		return nil	-- JSON supports nil values! It writes "null" instead of "nil".
	end
	
	-- Basic variables can be used as-is, safely.
	if _type == "boolean" or _type == "number" or _type == "string" then
		return _value
	elseif _type == "Color3" then
		return {_value.R, _value.G, _value.B}
	elseif _type == "BrickColor" then
		return _value.Name	-- Store the BrickColor's name, which can be used to recreate it later using BrickColor.new([name]).
	elseif _type == "ColorSequence" or _type == "NumberSequence" then	-- Sequences will be stored in their "string" form.
		if _value and tostring(_value):sub(-1,-1) ~= " " then return tostring(_value)	-- If the string doesn't end in an erroneous space, save as-is.
		else return tostring(_value):sub(1,-2)											-- Does it? If so, don't include the last character!
		end
	elseif _type == "NumberRange" then
		return {_value.Min, _value.Max}
	elseif _type == "UDim" then
		return {_value.Scale, _value.Offset}
	elseif _type == "UDim2" then
		return {_value.Width.Scale, _value.Width.Offset, _value.Height.Scale, _value.Height.Offset}
	elseif _type == "Rect" then	-- Rects are stored as the minimum Vector2 XY values followed by their "max" counterparts. Use Rect.new([1],[2],[3],[4])!
		return {_value.Min.X,_value.Min.Y,_value.Max.X,_value.Max.Y}
	elseif _type == "Font" then
		return {_value.Family, _value.Weight.Value, _value.Style.Value}	-- Save this font's properties. Reconstruct it using Font.new(family, weight, style).
	elseif _type == "Vector2" then
		return {_value.X, _value.Y}
	elseif _type == "Vector3" then
		return {_value.X, _value.Y, _value.Z}
	elseif _type == "EnumItem" then	-- Store the Enum's name, followed by the item within it. Reconstruct using Enum[item 1][item 2].
		return {tostring(_value.EnumType), _value.Name}
	elseif _type == "CFrame" then
		local X,Y,Z,R00,R01,R02,R10,R11,R12,R20,R21,R22 = _value:GetComponents()
		return {X,Y,Z,R00,R01,R02,R10,R11,R12,R20,R21,R22}	-- Return all components of this CoordinateFrame.
	elseif _type == "Instance" then	-- As Instances can't be saved, their debug ID is stored instead. (The plugin already expects one of these.)
		return _value:GetDebugId()
	elseif _type == "PhysicalProperties" then
		return {
			_value.Density,
			_value.Friction,
			_value.Elasticity,
			_value.FrictionWeight,
			_value.ElasticityWeight
		}
	elseif _type == "Faces" then	-- Create a list filled with Enum.FaceId values that can be passed to Faces.new() to reconstruct it.
		local __value : Faces = nil
		local FaceIdList	= {}
		if __value.Top then table.insert(FaceIdList, 1) end
		if __value.Bottom then table.insert(FaceIdList, 4) end
		if __value.Left then table.insert(FaceIdList, 3) end
		if __value.Right then table.insert(FaceIdList, 0) end
		if __value.Back then table.insert(FaceIdList, 2) end
		if __value.Front then table.insert(FaceIdList, 5) end
		return FaceIdList
	end
end

env.XRecreator.PageLength		= env.PageLength or 100		-- How many instances should be listed at a time.
env.XRecreator.AntiLagInterval	= env.AntiLagInterval or 25	-- To reduce lag, intensive actions are paused on every Nth processed Instance.

type InternalListEntry		= {
	Instance			: Instance,	-- Instance which this entry represents. Its class and name are used when generating the visible list.
	Level				: number	-- Represents the depth this instance was placed at in the hierarchy during the scan. 0 is the container itself.
}

-- The "actual" internal list of instances, which were found during the initial scan after clicking one of the "container" buttons.
-- To reduce lag, only a subset of this list is used at any time to generate the "visible list" (the ListData array). This array is wiped
-- when the UI is hidden and when switching between containers.

-- Entry 1 will always be a special entry which (de)selects the container itself.
--[[: {InternalListEntry}]]--
env.XRecreator.FullList = {}

-- An array of nested dictionary entries which contain any applicable properties of each supported instance. When a model is being
-- exported, the data gathered during the scan is put into this table. When multiple instances are exported at the same time, each
-- to-be JSON file's contents is exported from here, then this table is cleared before the next capture starts.
local OngoingExportData = {}

-- Roblox doesn't allow multiple copies of a container (workspace, ReplicatedStorage, etc.), so an "imposter" model is created for each of the
-- four selectable containers, used instead of one of them if an instance was formerly parented to one. This array links the actual containers'
-- debug IDs to the fake Models; When an instance is captured, its parent is forcibly changed to one of these dummies if it matches any
-- continers' debug IDs.
local ContainerRedirections : {string} = {}

-- Speaking of containers' imposters, let's create the four Models now then place them in ServerStorage, which is basically unused on the client.

-- Class names to treat as the forbidden containers. (Not used here.)
local ContainerList = { "Workspace", "Players", "Lighting", "ReplicatedStorage", "StarterGui", "SoundService", "StarterPack"}
for _,locat : Instance in pairs({workspace,Players,Lighting,ReplicatedStorage,StarterGui,SoundService,StarterPack}) do
	local dummyModel = Instance.new("Model", ServerStorage)
	dummyModel.Name = locat.Name
	ContainerRedirections[locat:GetDebugId()] = dummyModel:GetDebugId()
end

print("✅Reached functions section of script...")

-- FUNCTIONS

--[[
	IsInstanceAllowed (takes Instance reference, returns boolean)
	Checks for some specific instances that shouldn't be saved, either because they cause softlocks/glitches or
	would be useless in the context of saving instances or places within experiences. Here are the reasons:
	
	Camera within workspace - This conflicts with Studio's editor camera, and isn't particularly useful.
	Character inside Player - Player character links are unstable, and usually lock up this script.
]]--
function env.XRecreator.IsInstanceAllowed(_instance : Instance)
	if not _instance.Parent then return false
	elseif (_instance.Parent == workspace and _instance:IsA("Camera")) or
		(_instance.Parent:IsA("Player") and _instance.Name == "Character")
	then
		return false
	else return true
	end
end

local function DisplayError(_message : string, _length : number)
	built_in_error.Visible = true
	built_in_error.Text = _message
	task.wait(_length)
	built_in_error.Visible = false
	
	return nil
end

-- An important function, responsible for turning an Instance into data, which is later encoded as a JSON array/dictionary.
-- This function is also responsible for remapping/re-parenting direct children of containers to the fake "Models" found in
-- ServerStorage at runtime. Though there was a third argument to this function that made it remove the Instance's parent,
-- it has been removed; If an Instance references a debug ID with no cooresponding Instance, the Studio plugin should just
-- parent it to that container's "main model" (which is its counterpart to the "imposter" models).
local function CaptureInstance(_instance : Instance, _destination : {any})
	local replacementParent : string? = nil
	local ParentDebugId : string? = nil
	
	-- Does this instance still have a parent? Usually, every instance should be parented, but as the Instance list is only generated
	-- on request (when the user taps on one of the container buttons), any of the Instances that they've chosen may have been removed
	-- by the game by the time they start trying to capture them! If this instance has a parent, try to get its debug ID for reference.
	if _instance.Parent then
		-- Check to see if this instance's parent is one of the four supported containers. We can't recreate these containers, so let's
		-- try to find a new "imposter" to parent it to.
		for oldId : string,newId : string in ContainerRedirections do
			if _instance.Parent:GetDebugId() == oldId then	-- Looks like we have a match! Link it to this container's fake counterpart.
				replacementParent = newId	-- We'll save this instance with false metadata, linking it to the "wrong" Model.
				break
			end
		end
		
		-- Also, let's go ahead and get the parent Instance's debug ID while we're at it. When this Instance's dictionary entry is
		-- generated next, it'll prioritize the "parent replacement" above over this. It'll choose the "imposter container"'s debug
		-- ID, then the parent's actual debug ID if it can't find that, followed by just setting its parent to "nil".
		ParentDebugId		= _instance.Parent:GetDebugId()
	end
	local InstDictionary	= {	-- Every Instance has references to its name, class, debug ID, and its parent's debug ID.
		Name				= _instance.Name,
		ClassName			= _instance.ClassName,
		DebugId				= _instance:GetDebugId(),	-- This is required; The plugin uses it to link Instances while it imports everything.
		Parent				=	-- Assign this instance's parent based on if it has a replacement or has a parent.
			if replacementParent then replacementParent	-- Is this parented to a known container? Use the dummy Model's debug ID instead.
			elseif ParentDebugId then ParentDebugId		-- If not, did its parent have a valid debug ID (which it should)? Use that!
			else StoreValue(nil, "nil")					-- Otherwise, the parent's nil, so it'll be imported under this container's model.
	}
	-- print("Wrote basic property set for", _instance.Name, "whose parent is ID", InstDictionary.Parent)
	
	-- Additional properties specific to this class are added to this dictionary entry next. If a property's name starts
	-- with "UseCmnList_", a secondary list of properties is checked and added to this list.
	for property1 : string,type1 : string in pairs(env.XRecreator.ClassData[_instance.ClassName].Props) do
		if property1:find("UseCmnList_") then
			-- print("This instance type uses a shared property list,", type1)
			-- print("Does that shared list exist?")
			if CommonPropList[type1] then
				for property2 : string, type2 : string in pairs(CommonPropList[type1]) do
					InstDictionary[property2] = StoreValue(_instance[property2], type2)
				end
			end
		else	-- If this is a property listed inline for this class, just try to store its value in the dictionary entry.
			InstDictionary[property1] = StoreValue(_instance[property1], type1)
			-- print("Property", property1, "found! Adding value to table as", InstDictionary[property1])
		end
	end
	
	-- Lastly, see if this Instance has any attributes and/or tags; These will be exported with in the instances' serialized JSON versins.
	local temp_attribList = _instance:GetAttributes()
	local temp_attribcount = 0	-- Figure out how many attributes this instance has.
	for _,_ in pairs(temp_attribList) do temp_attribcount += 1 end
	if temp_attribcount > 0 then
		InstDictionary.Attributes = {}	-- It has some? Create an empty dictionary entry, then store all of them in here.
		for name,value in pairs(temp_attribList) do
			InstDictionary.Attributes[name] = {}	-- Each attribute's key contains its value ([1]) then its variable type ([2]).
			InstDictionary.Attributes[name][1] = StoreValue(value, typeof(value))
			InstDictionary.Attributes[name][2] = tostring(typeof(value))
		end
	end
	
	-- Are there any tags on this Instance? If there are, add them to a new sub-array like with attributes. (This time it's a basic array, though!)
	if #_instance:GetTags() > 0 then
		InstDictionary.Tags = {}
		for _,tag in pairs(_instance:GetTags()) do table.insert(InstDictionary.Tags, tag) end
	end
	
	_destination[#_destination+1] = InstDictionary
	return true
end

--[[
	One of the most important functions in the Model Recreator script! This function iterates through all of the children of
	an instance, recursively repeating the process as it advances deeper into the hierarchy, performing an action on every
	instance that it finds.
	
	If _mode is "list", every instance is added to the "explorer" list in the window. With "capture", it creates dictionary entries
	for each instance, adding them to _dest (a table). _level increases on every recursion, and determines where the next call
	will write its data to. Lastly, this just "caches" all instances' debug IDs within the specified Instance in "debug" mode.
]]--
local AntiLagInstCounter		= 0	-- A counter, which determines when ApplyChildAction() will wait for a frame to keep the client from completely freezing.
local ProgressVars					= {
	TotalInstances					= nil,	-- A count of all descendants of the selected container, used for the progress UI while indexing only.
	CurrentInstance					= 0,	-- When TotalInstances is setup, this represents how many Instances that ApplyChildAction has checked.
	Prefix							= "Indexing instances..."
}

local function ApplyChildAction(_base : Instance, _mode : "list"|"capture", _level : number, _dest : {any})
	-- If a capture is just starting, capture the selected Instance itself as level 1, then everything within it as higher levels.
	-- This is pretty hackish, but it's debatably the best way to approach this scenario.
	-- If the base Instance is one of the four containers, it's ignored, only capturing the instances within it.
	print("ApplyChildAction started with parameters ", _base, _mode, _level)
	if _mode == "capture" and _level <= 1 then
		-- print("Capturing base instance", _base:GetFullName())
		if not table.find(ContainerList, _base.ClassName) then CaptureInstance(_base, _dest) end
		_level += 1
		-- _dest = _dest[#_dest]
	end
	
	for num,inst : Instance in pairs(_base:GetChildren()) do
		AntiLagInstCounter += 1	-- Always count Instances towards the anti-lag code; Lag is annoying (and risky for exploiters), y'know!
		if ProgressVars.TotalInstances then	-- If we're tracking all of the instances to show progress (in UI), increment the "current" counter.
			ProgressVars.CurrentInstance += 1
		end
		
		-- See if this Instance's class is supported by this script. If it isn't, ignore it and advance to the next one in line.
		if env.XRecreator.ClassData[inst.ClassName] and env.XRecreator.IsInstanceAllowed(inst) and
			not inst:GetAttribute(env.XRecreator.IgnoreAttrib)
		then
			if _mode == "list" then	-- Log all supported instances to the instance list.
				local newEntry : InternalListEntry = {
					Instance = inst,
					Level = _level
				}
				print("Added item #", #env.XRecreator.FullList, "to the list...")
				table.insert(env.XRecreator.FullList, newEntry)
			elseif _mode == "capture" then
				CaptureInstance(inst, _dest)
				
				-- print("Added instance definition for", inst.Name, "!")
				--table.insert(_dest, InstDictionary)	-- Add this Instance's serialized form to the dictionary!
			end
			
			if AntiLagInstCounter % env.XRecreator.AntiLagInterval == 0 then task.wait() end	-- Wait a frame every so often.
			
			-- Does this instance have any child instances? Start a new instance of this function, checking those out for now.
			if #inst:GetChildren() > 0 then
				if _mode == "list" then
					print("This instance has children! About to list them:")
					ApplyChildAction(inst, "list", _level+1, nil)
				elseif _mode == "capture" then
					-- print("Destination is",_dest, "and current instance is", inst:GetFullName())
					-- print("It has",#_dest,"entries in it. The next recursion should write tis dictionary entries there.")
					ApplyChildAction(inst, "capture", _level+1, _dest)	-- _dest[#_dest])
				else ApplyChildAction(inst, "debug", _level+1, nil)
				end
			end
		elseif ProgressVars.TotalInstances then	-- If an Instance's skipped during indexing, still count all of its descendants in the count.
			print("elseif ProgressVars.TotalInstances then")
			local temp_descendants = #inst:GetDescendants()
			if temp_descendants > 0 then
				print("ProgressVars.CurrentInstance += temp_descendants")
				ProgressVars.CurrentInstance += temp_descendants
			end
		end
		
		-- Lastly, update the progress window's text, if it's currently needed (or relevant).
		if ProgressVars.TotalInstances then
			print("Trying to update the status GUI's text...", env.XRecreator.StatusGui)
			env.XRecreator.StatusGui.Text =
				tostring(ProgressVars.Prefix).."\u{000D}\u{000A}"..tostring(ProgressVars.CurrentInstance).." / "..tostring(ProgressVars.TotalInstances)
		end
	end
end

print("✅Processed miscellaneous functions.")

-- PUBLIC API FUNCTIONS
-- These actions can be called from other scripts to modify the current selection, make lists (for GUIs), and save everything to JSON files.

-- Recreator.MakeList (takes Instance reference, returns booolean)
-- A wrapper for ApplyChildAction's list mode, which iterates through all descendants of a given Instance, noting the names and
-- depths (how deep in the hierarchy) of each one. This function should yield execution until it finishes, so the caller should
-- automatically wait until indexing finishes, and can check if this operation completed successfully by checking return value.
function env.XRecreator.MakeList(_base : Instance)
	ProgressVars.CurrentInstance = 0
	ProgressVars.TotalInstances = #_base:GetDescendants()
	ProgressVars.Prefix = "Indexing instances..."
	print(ScriptName .. "About to make a list, starting from base " .. tostring(_base) .. "...")
	local success, errormsg = pcall(function() ApplyChildAction(_base, "list", 1, nil) end)
	ProgressVars.TotalInstances = nil
	if not success then warn(ScriptName .. "Couldn't finish generating list because " .. tostring(errormsg)) end
	return success
end

-- Recreator.ActivateAPI (takes boolean, returns boolean)
-- A very weak "lock" that depends on trust between scripts. Any cooperating scripts should use this function to "claim" the
-- API while they're running, calling this with a "false" parameter right as they close. This will prevent conflicts.
function env.XRecreator.ActivateAPI(_use : boolean)
	if _use and env.XRecreator.Reserved then
		return false
	else
		if not _use then	-- If releasing the API, reset it back to its initial state.
			if env.XRecreator.StatusGui ~= built_in_status then
				env.XRecreator.SetStatusGui(nil)
			end
			env.XRecreator.OnSaveDone = nil
			env.XRecreator.IgnoreAttrib = "Dummy"
			table.clear(env.XRecreator.FullList)
			env.XRecreator.Select("set", {})
		end
		
		env.XRecreator.Reserved = _use
		return true
	end
end

-- Recreator.SetStatusGui (takes optional TextLabel reference, returns nothing)
function env.XRecreator.SetStatusGui(_gui : TextLabel?)
	if _gui and _gui:IsA("TextLabel") then
		env.XRecreator.StatusGui.Visible = false	-- Hide the current GUI as soon as the change happens.
		print("A script has set the Recreator API's status GUI to " .. _gui:GetFullName())
		env.XRecreator.StatusGui = _gui
	else
		env.XRecreator.StatusGui = built_in_status	-- If no label is provided, or it's the wrong Instance type, use the built-in GUI instead.
	end
	return nil
end

local function ClearSelection()
	env.XRecreator.EmptyDebugIDCache()	-- When the main window is hidden, all debug IDs are forgotten and the instance list is emptied.
	table.clear(env.XRecreator.FullList)
	table.clear(env.XRecreator.Selection)	-- Deselect all Instances, which comnpletes the main window's reset.
	-- CheckSavePrerequisites()		-- Make the save button check to see if it should allow exporting of the...deselected instances (it won't).
end

local SelectModes = { "set", "add", "remove" }
function env.XRecreator.Select(_mode : "set"|"add"|"remove", _list : {Instance})
	if not _mode or not _list then return false
	elseif type(_mode) ~= "string" or (type(_mode) == "string" and not table.find(SelectModes, _mode)) then return false
	elseif type(_list) ~= "table" then return false
	else
		if _mode == "set" then
			if _list == {} then
				ClearSelection()
			else
				env.XRecreator.Selection = _list
			end
		else
			for _,item in _list do
				if _mode == "add" and not table.find(env.XRecreator.Selection, item) then
					table.insert(env.XRecreator.Selection, item)
				elseif _mode == "remove" and table.find(env.XRecreator.Selection, item) then
					table.remove(env.XRecreator.Selection, table.find(env.XRecreator.Selection, item))
				end
			end
		end
		return true
	end
end

function env.XRecreator.CustomizeProgressBox(_message : string, _total : number)
	if _message and type(_message) == "string" then
		ProgressVars.Prefix = _message
		ProgressVars.TotalInstances = _total
		ProgressVars.CurrentInstance = 0
	end
end

print("✅Processed all but Recreator.Save() function...")

-- Recreator.Save (takes string, returns nothing)
-- Perhaps THE most important function in the recreator API! This stores important info about containers and the capture, plus grabs
-- info about the current place's MaterialService material variants and lighting properties, storing all of this data in a "header"
-- file. After creating this file, a JSON file is also written for each selected instance (piece), which contains text conversions of
-- every instance this API finds and serializes.

-- When this function finishes executing, Recreator.OnSaveDone's code runs, allowing other scripts to clean up their GUI or do actions; If
-- everything saves, its first argument will be TRUE.
function env.XRecreator.Save(_filename:string?) : boolean
	-- env.XReecreator.StatusGui.Text = "Preparing to export the selected instances..."
	
	print(ScriptName .. "Got a request to save " .. tostring(#env.XRecreator.Selection) .. " items to " .. _filename .. "!")
	-- Check to make sure that every selected Instance still exists, cleaning up any "dead" references if they're found in it.
	-- As table.remove() shifts arrays' contents around as it removes things from them, we have to do another one of THESE endless
	-- for loops, restarting every time something has to be removed from the list.
	local OrigSelectionSize = #env.XRecreator.Selection	-- Note how many Instances are selected before cleaning the array up. If that lowers, this is used.
	local SelectionCleanedUp = false
	local Restarting = false	-- When this is TRUE, the outer for loop will break immediately, letting the loop start from the beginning.
	while not SelectionCleanedUp do
		for num,_inst : Instance in pairs(env.XRecreator.Selection) do	-- For each selected Instance...
			---- message.Text = "Checking instance " .. num .. "/" .. #env.XRecreator.Selection .. "..."
			print(ScriptName .. "Checking instance " .. num .. "/" .. #env.XRecreator.Selection .. "...")
				
			-- Does this Instance have a parent? If it doesn't, remove it from the selection then start over.
			-- Also, don't save anything inside MaterialService; PBR materials are included in the save's header!
			if (_inst and not _inst.Parent) or
				_inst and (_inst:IsA("MaterialService") or _inst:FindFirstAncestorWhichIsA("MaterialService"))
			then
				table.remove(env.XRecreator.Selection, num)
				---- message.Text = "Welp, Instance ID " .. id .. " doesn't exist now, so it isn't included now."
				DisplayError("Instance " .. tostring(_inst:GetFullName()) .. " couldn't be found, so it won't be saved.", 3)
				print("Instance", tostring(_inst:GetFullName()), "couldn't be found, so it won't be saved.")
				-- task.wait(1.5)		-- Wait one and a half seconds so the message above can be read before it's updated again.
				Restarting = true	-- Cut off this process now, to make sure that the entire selection gets scanned.
			end
			
			-- If part of the selection couldn't be found above, the whole while loop is about to restart, so this for loop has to end now.
			if Restarting then break end
		end
		
		-- If the for loop completed without requesting a do-over, this while loop can safely end now. Otherwise, unset the flag and start over.
		if not Restarting then
			SelectionCleanedUp = true
		else Restarting = false
		end
	end
	
	-- If any Instances were unparented or removed since they were selected, notify the user before proceeding.
	if #env.XRecreator.Selection < OrigSelectionSize then
		DisplayError("Only " .. #env.XRecreator.Selection .. " of " .. OrigSelectionSize .. " selections can be saved. Sorry!", 5)
	end
	
	-- First, let's write the "header" file, which will tell the Studio plugin where it should place each exported "model", the export's
	-- folder name (its filename), and other information. To get this info, we have to look through the currently-selected instances and
	-- figure out if anything was saved from PlayerGui, ReplicatedStorage, or Lighting.
	local HeaderContents	= {
		Metadata			= {
			Name			= _filename,			-- Place all exported instances from this package into a Model named this (see below).
			PlaceId			= game.PlaceId or 0,	-- The ID of the place where this rip was done, which will be saved as an IntValue.
			GameId			= game.GameId or 0,		-- This experience's ID number, for reference, just like the previous ID.
		},
		
		-- Any MaterialVariants found within MaterialService are stored here, in a format similar to that of pieces' entries.
		MaterialVariants	= {},
		
		-- Lighting properties are always saved, but they aren't used unless "Apply" is set to TRUE.
		LightingProperties						= {
			Ambient								= StoreValue(Lighting.Ambient, "Color3"),
			Brightness							= Lighting.Brightness,
			ColorShift_Top						= StoreValue(Lighting.ColorShift_Top, "Color3"),
			ColorShift_Bottom					= StoreValue(Lighting.ColorShift_Bottom, "Color3"),
			EnvironmentDiffuseScale				= Lighting.EnvironmentDiffuseScale,
			EnvironmentSpecularScale			= Lighting.EnvironmentSpecularScale,
			GlobalShadows						= Lighting.GlobalShadows,
			OutdoorAmbient						= StoreValue(Lighting.OutdoorAmbient, "Color3"),
			ShadowSoftness						= Lighting.ShadowSoftness,
			ClockTime							= Lighting.ClockTime,
			GeographicLatitude					= Lighting.GeographicLatitude,
			FogColor							= StoreValue(Lighting.FogColor, "Color3"),
			FogEnd								= Lighting.FogEnd,
			FogStart							= Lighting.FogStart
		},
		
		-- Store all four containers' "imposter" debug IDs. Before the Studio plugin starts to "import" instances, it should create four
		-- dummy Models, one in each of the supported containers. As each is created, it must be associated with its respective "debug ID"
		-- in this array, which should be consistent with debug IDs used by captured instances which were direct children of workspace,
		-- ReplicatedStorage, or another container.
		
		-- When no matches are found for a "debug ID" when they're being linked, the instances should be forcibly parented to the Model
		-- in that piece's container (which can be found in the PieceInfo array within the header). Also, each Model should be named
		-- after the export ([header].Metadata.Name).
		ImposterIds								= {
			ContainerRedirections[workspace:GetDebugId()],
			ContainerRedirections[Players:GetDebugId()],
			ContainerRedirections[Lighting:GetDebugId()],
			ContainerRedirections[ReplicatedStorage:GetDebugId()],
			ContainerRedirections[StarterGui:GetDebugId()],
			ContainerRedirections[SoundService:GetDebugId()],
			ContainerRedirections[StarterPack:GetDebugId()]
		},
		
		-- Stores info about every part of this export. This is used to validate that enough JSON entries have been provided and where to
		-- place their contents. (Captures within PlayerGui are put in StarterGUI, and every other container adds the models' contents to
		-- a subfolder within that specific location.)
		PieceInfo								= {
		}
	}
	print(ScriptName .. "Generated most header info. About to find each piece...")
	
	for i,_inst : Instance in pairs(env.XRecreator.Selection) do
		-- Generate this piece's GUID and set its import location now, so this piece can always be imported, even if its instance isn't checked.
		local PieceEntry							= {
			InsertLocation							= "workspace",
			BaseInstName							= "UnknownBaseInstance",
			GUID									= HttpService:GenerateGUID(false)
		}
		-- Could we find this selected Instance? Figure out its container, then write that down for the plugin.
		if _inst then
			local inWorkspace, inPlayers, inPlayerGui, inLighting, inRepStore, inSoundService, inStarterPack =
				_inst:IsDescendantOf(workspace),
				_inst:IsDescendantOf(Players),
				_inst:IsDescendantOf(PlayerGui) or _inst:IsDescendantOf(StarterGui),
				_inst:IsDescendantOf(Lighting),
				_inst:IsDescendantOf(ReplicatedStorage),
				_inst:IsDescendantOf(SoundService),
				_inst:IsDescendantOf(StarterPack)
			
			PieceEntry.BaseInstName					= _inst.Name
			PieceEntry.InsertLocation				=
				if inPlayerGui then "playergui"
				elseif inPlayers then "players"
				elseif inLighting then "lighting"
				elseif inRepStore then "repstore"
				elseif inSoundService then "sndservice"
				elseif inStarterPack then "startpack"
				else "workspace"
		end
		
		print(ScriptName .. "Piece " .. i .. " is in the " .. PieceEntry.InsertLocation .. ".")
		HeaderContents.PieceInfo[i]		= PieceEntry	-- Add this piece's information to the array, then continue and add the rest of them.
	end
	
	-- Just before the header is written to file, any material definitions are written down in its MaterialVariants sub-array.
	local MatList						= MaterialService:GetDescendants()
	if #MatList > 0 then
		print(ScriptName .. "This place has custom materials. Copying them...")
		for i,material : MaterialVariant in pairs(MatList) do
			---- message.Text = "Grabbing material variants... (" .. (i/#MatList)*100 .. "%)"
			if material:IsA("MaterialVariant") then
				print("Found", material.Name)
				table.insert(HeaderContents.MaterialVariants, {
					Name				= material.Name,
					BaseMaterial		= StoreValue(material.BaseMaterial, "EnumItem"),
					MaterialPattern		= StoreValue(material.MaterialPattern, "EnumItem"),
					ColorMap			= material.ColorMap,
					NormalMap			= material.NormalMap,
					MetalnessMap		= material.MetalnessMap,
					RoughnessMap		= material.RoughnessMap,
					StudsPerTile		= material.StudsPerTile
				})
			end
		end
	end
	
	-- Write the header/metadata to this export's "main file".
	print(ScriptName .. "Writing header section...")
	writefile(_filename .. "_header.json", game:GetService("HttpService"):JSONEncode(HeaderContents))
	
	-- With the header data written to a file, the actual exporting can begin! Hide the main interface, as it's probably disabled at this point.
	-- ToggleUI(true)
	
	for i,target : Instance in env.XRecreator.Selection do
		-- Set up and show the "indexing progress" UI, which will be updated by ApplyChildAction(), so the user isn't left in the dark.
		---- message.Text = "Saving selection " .. i .. "/" .. #env.XRecreator.Selection .. " (" .. HeaderContents.PieceInfo[i].BaseInstName .. ")"
		
		if env.XRecreator.StatusGui == built_in_status then
			built_in_status.Visible = true	-- For now, make the UI pop up rather than sliding in like the other frames would.
		end
		
		OngoingExportData = {}	-- Always ensure the "scrapbook" array is empty before exporting part of this "model".
		print(ScriptName .. "Serializing/saving piece " .. i .. "/" .. #env.XRecreator.Selection .. "...")
		-- print("Debug ID", target, "/Instance", DebugIDList[target])
		
		ProgressVars.CurrentInstance = 0
		ProgressVars.TotalInstances = #target:GetDescendants()
		ProgressVars.Prefix = "Saving piece " .. i .. "/" .. #env.XRecreator.Selection .. "..."
		local success, msg = pcall(function() ApplyChildAction(target, "capture", 1, OngoingExportData) end)	-- Try to "capture"!
		ProgressVars.TotalInstances = nil
		if not success then
			if env.XRecreator.StatusGui == built_in_status then
				built_in_status.Visible = false	-- Hide the progress UI.
			end
			DisplayError("Oh no! Piece #" .. i .. " couldn't be captured because of this error: \"" .. msg .. "\".", 7)
			if env.XRecreator.OnSaveDone then
				env.XRecreator.OnSaveDone(false)
			end
			error("Piece " .. i .. " of export " .. _filename .. " couldn't be completely captured.")
		end
		if #OngoingExportData > 0 then
			OngoingExportData[1].GUID	= HeaderContents.PieceInfo[i].GUID	-- Add this piece's GUID to the first instance entry as a "property".
			pcall(function()
				writefile(_filename .. "_piece" .. i .. ".json", game:GetService("HttpService"):JSONEncode(OngoingExportData))
			end)
			
			if i == #env.XRecreator.Selection then	-- Was that the last piece? If so, we're done! Clear the user's selection and finish up.
				if env.XRecreator.StatusGui == built_in_status then
					built_in_status.Visible = false	-- Hide the progress UI.
				end
				
				if env.XRecreator.OnSaveDone then
					env.XRecreator.OnSaveDone(true)
				end
			end
		else
			if env.XRecreator.StatusGui == built_in_status then
				built_in_status.Visible = false	-- Hide the progress UI; We're about to display the list that was just put generated.
			end
			---- message.Text = "Uh-oh! Piece #" .. i .. " wasn't saved for some reason!"
			if env.XRecreator.OnSaveDone then
				env.XRecreator.OnSaveDone(false)
			end
			DisplayError("Piece " .. i .. " of export " .. _filename .. " wasn't converted to a dictionary correctly.", 5)
			error("Piece " .. i .. " of export " .. _filename .. " wasn't converted to a dictionary correctly.")
		end
	end
end
print("✅Almost done... Initialized Save() (exporting function) successfully. Preparing to add importing function from Studio plugin...")

-- Dictionary returned after successfully importing/loading serialized JSON data using Recreator.Load(). Each key is named after
-- and points to the Model that the function placed your imported Instances into, and will be nil if nothing was imported to a
-- location. If the third argument is set to an Instance, all models will be put there instead of in each container...
type XRecreatorImportResult	= {
	Success				: boolean,
	Workspace			: Model?,
	Players				: Model?,
	Lighting			: Model?,
	ReplicatedStorage	: Model?,
	StarterGui			: Model?,
	SoundService		: Model?,
	StarterPack			: Model?
}

-- One of the most important functions here; This creates all of the instances within an import and "recreates" them here! This function
-- was originally written for Xane's Asset Importer, the companion Roblox Studio plugin, but has been tweaked for the Recreation API!
-- The plugin can support older 4-container and newer 7-container captures, but this script will only handle the latter ([7])!
local ImposterDestInfo					= {
	[7]									= {
		-- Later exports may add 3 more supported containers, copying Instances from PlayerGui into StarterGui instead of Players.
		-- The four containers are for workspace, Players, Lighting, and ReplicatedStorage in that order.
		{
			Instance					= workspace,
			AbbrevDestName				= "workspace"
		},
		{
			Instance					= game:GetService("Players"),
			AbbrevDestName				= "players"
		},
		{
			Instance					= Lighting,
			AbbrevDestName				= "lighting"
		},
		{
			Instance					= ReplicatedStorage,
			AbbrevDestName				= "repstore"
		},
		{
			Instance					= StarterGui,
			AbbrevDestName				= "playergui"
		},
		{
			Instance					= game:GetService("SoundService"),
			AbbrevDestName				= "sndservice"
		},
		{
			Instance					= game:GetService("StarterPack"),
			AbbrevDestName				= "startpack"
		}
	}
}

-- A small array which uses string indexes to associate the "keywords" in the dictiomnary entries above to the final "imposter" containers.
local ImposterDB						= {}

-- A list of Instance classes that should be silently replaced with Models due to Roblox's arbitrary limits on which classes scripts can create.
local InvalidClasses					= {
	"Player",
	"PlayerGui"
}

--[[
	ImportAsset (takes two or more specifically formatted dictionaries and boolean, returns specifically-formatted dictionary entry)
	Attempts to parse the provided header and piece data, converting everything into Instances. The header and piece array should be
	decoded dictionaries instead of JSON strings!
	
	After all Instances have formed and been moved to their container-specific Models, references to those Models will be returned in
	a dictionary, enabling automation and further modifications using scripts.
]]--
type XRecreatorLoadConfig				= {
	Destination							: Instance?,	-- If defined, all container Models will be placed inside this Instance.
	AddMaterials						: boolean,		-- Import MaterialVariants from this save to MaterialService? (Detectable)
	ApplyLighting						: boolean		-- Sets all standard Lighting properties to the origin place's. (Useless.)
}

function ImportAsset(_header : any, _pieces : {any}, _config : XRecreatorLoadConfig)
	table.clear(ImposterDB)	-- Clear the imposter Model database/array, making sure each import is done from a fresh state.
	table.clear(DebugIDList)	-- Also wipe the debug ID list, so it isn't filled with useless references to previous imports.
	
	if not _config or type(_config) ~= "table" then	-- If settings weren't given, define the default set.
		_config = {
			Destination					= nil,
			AddMaterials				= false,
			ApplyLighting				= false
		}
	end
	
	-- Any Models created by this function will be returned to the caller. When everything's pladced in a specific place, the
	-- "outer container model" isn't included in this list; To destroy it, just use Result.Workspace.Parent:Destroy().
	local Result : XRecreatorImportResult	= {
		Success = false,	-- Assume failure by default.
		Workspace = nil,
		Players = nil,
		Lighting = nil,
		ReplicatedStorage = nil,
		StarterGui = nil,
		SoundService = nil,
		StarterPack = nil
	}
	
	--[[
		First, create the four container imposters. Imported assets will be inserted into these, which keeps the workspace organized!
		One Model is created and any relevant metadata is used to help the user identify an import, in case they're doing a bulk operation.
		This Model is cloned to all supported containers. If only four imposter debug IDs are listed in the header, all Players-related instances
		will be put in StarterGui (which is always done at the moment).
	]]--
	
	local success, errormsg = pcall(function()
		-- Page4_Message.Text						= "Preparing to import... (Generating containers.)"
		Recreator.StatusGui.Text = "Preparing to import... (Generating containers.)"
		if Recreator.StatusGui == built_in_status then
			built_in_status.Visible = true	-- Show the built-in status GUI if it's hidden.
		end
		local OuterContainer : Model?			= nil	-- In all-workspace mode, all containers are placed within ANOTHER Model in workspace.
		local initial_container_to_clone		= Instance.new("Model")
		initial_container_to_clone.Name			= _header.Metadata.Name	-- .. "_" .. HttpService:GenerateGUID(false):sub(1,8)	-- Append 8 random digits.
		initial_container_to_clone:SetAttribute("OriginGameId", _header.Metadata.GameId)		-- Store the game's ID and place ID as attributes.
		initial_container_to_clone:SetAttribute("OriginPlaceId", _header.Metadata.PlaceId)
		initial_container_to_clone:SetAttribute("TotalPieces", #_header.PieceInfo)
		-- initial_container_to_clone:SetAttribute("Credit", "Imported using Xane's Recreation API!")
		
		-- If a destination is specified, every container's submodel will be placed inside of it. This is inconsistent with the Studio plugin,
		-- which would create a Model named after the saved file instead. Well, hey, what works in Studio doesn't quite work for gameplay, y'know.
		if _config.Destination and typeof(_config.Destination) == "Instance" then
			OuterContainer						= _config.Destination	-- initial_container_to_clone:Clone()
		end
		
		-- Create each "imposter" container, assigning it to the debug ID that it used in the game it came from.
		-- The variable assignment last in this loop assigns Model to its container "keyword", used if an orphan needs to be parented to container.
		for i : number,debugId : string in _header.ImposterIds do	
			local NewImposter					= initial_container_to_clone:Clone()
			if _config.Destination and typeof(_config.Destination) == "Instance" then	-- In "all-workspace" mode, Models are stored within another named after export, so use container names.
				NewImposter.Name				= ImposterDestInfo[#_header.ImposterIds][i].Instance.Name
			end
			NewImposter.Parent					= OuterContainer or ImposterDestInfo[#_header.ImposterIds][i].Instance
			DebugIDList[_header.ImposterIds[i]] = NewImposter	-- Link this Instance to its intended debug ID.
			ImposterDB[ImposterDestInfo[#_header.ImposterIds][i].AbbrevDestName] = NewImposter
		end
		initial_container_to_clone:Destroy()	-- Destroy the template, as it's no longer needed.
		
		--[[
			Make a new MeshPart, which will temporarily hold on to all of the imported assets. This is needed for things like Attachments and
			SurfaceAppearance instances, which require this class to spawn, annoyingly. In the future, more of these temporary storage
			containers may be necessary, picked based on the instance type. (Animators and other picky instances could then be saved!)
		]]--
		
		local TempDirectory						= Instance.new("MeshPart")
		TempDirectory.Size						= Vector3.one
		TempDirectory.Anchored					= true
		TempDirectory.Name						= "Importing... Please wait."
		TempDirectory.Parent					= CoreGui
		
		-- If it's been requested for this import, go ahead and recreate any MaterialVariants that the originating game was using.
		-- Without these, meshes may look off, so that's why UseMateirals is set by default.
		if _header.MaterialVariants and #_header.MaterialVariants > 0 and _config.AddMaterials then
			-- Create a new folder for this import's materials, to keep existing projects 
			local MatFolder						= Instance.new("Folder")
			MatFolder.Name						= _header.Metadata.Name	-- .. "_" .. HttpService:GenerateGUID(false):sub(1,8)	-- Append 8 random digits.
			MatFolder.Parent					= MaterialService
			
			-- Add each MaterialVariant to the new folder that we just made.
			for _,material in _header.MaterialVariants do
				local temp_newMatVar			= Instance.new("MaterialVariant")
				temp_newMatVar.BaseMaterial		= GetValue(material.BaseMaterial, "EnumItem")
				temp_newMatVar.MaterialPattern	= GetValue(material.MaterialPattern, "EnumItem")
				temp_newMatVar.ColorMap			= material.ColorMap
				temp_newMatVar.NormalMap		= material.NormalMap
				temp_newMatVar.MetalnessMap		= material.MetalnessMap
				temp_newMatVar.RoughnessMap		= material.RoughnessMap
				temp_newMatVar.StudsPerTile		= material.StudsPerTile
				temp_newMatVar.Name				= material.Name
				temp_newMatVar.Parent			= MatFolder
			end
		end
		
		-- Import all Instances from every piece, dumping them all into the "messy pile" MeshPart.
		for i,piece in _pieces do
			-- Page4_Message.Text						= "About to begin importing piece " .. i .. "."
			Recreator.StatusGui.Text				= "About to begin importing piece " .. i .. "."
			for entry,inst in piece do
				-- Page4_Message.Text					= "Creating instance " .. entry .. "/" .. #_pieces[i] .. " from piece " .. i .. "..."
				Recreator.StatusGui.Text			= "About to begin importing piece " .. i .. "."
				local NewInstance					= nil
				local temp_classname				= inst.ClassName
				local temp_isforbidden : number?	= nil	-- If this instance is a Player or PlayerGui, it isn't allowed and will become a Model.
				if table.find(InvalidClasses, temp_classname) then temp_classname = "Model" end
				
				-- MeshParts must be created using InsertService:CreateMeshPartAsync().
				if temp_classname == "MeshPart" and inst.MeshId and inst.MeshId:len() > 0 then
					-- print("Piece", i, "entry", entry, "is about to create a mesh using ID", inst.MeshId)
					local success, errormsg = pcall(function()
						NewInstance					= game:GetService("InsertService"):CreateMeshPartAsync(
							inst.MeshId,
							GetValue(inst.CollisionFidelity, "EnumItem"),
							GetValue(inst.RenderFidelity, "EnumItem")
						)
					end)
					if not success then
						warn("Xane's Model Recreator (Plugin) - Piece "..i.." entry "..entry.." tried to use an invalid mesh, "..tostring(inst.MeshId))
						NewInstance					= Instance.new(temp_classname)	-- Just create a blank MeshPart if it can't be created normally.
						NewInstance:SetAttribute("ImportFail_MeshId", inst.MeshId)	-- Write the original mesh ID in an attribute in case it helps.
					end
				else	-- For anything else, just use Instance.new() to create the necessary instances, including meshless MeshParts.
					NewInstance					= Instance.new(temp_classname)
				end

				-- Name this instance, toss it in the pile, then assign its former debug ID to it. We aren't going to setup its properties until
				-- all of the Instances exist; Some properties link Instances together, so we need a complete list of debug IDs before then.
				NewInstance.Name				= inst.Name
				NewInstance.Parent				= TempDirectory	-- TODO: Try commenting this out once Instances are parented to their intended parents.
				DebugIDList[inst.DebugId] = NewInstance	-- Add this Instance to the debug ID array.
				_pieces[i][entry].Instance	= NewInstance	-- Also store a reference to the final Instance inside of its _pieces entry.
				
				-- If this instance had attributes set on it, restore those by applying them to this instance.
				-- This is currently disabled because the script doesn't save attributes properly; This plugin expects an attribute's entry
				-- to include an array with two items, its serialized form ([1]) then its type as a string ([2]), but for whatever reason,
				-- it's just storing the value by itself! This confusing bug caused this section to be disabled for now.
				--[[
					if _pieces[i][entry].Attributes then
						for name,data in _pieces[i][entry].Attributes do
							print("Attribute detected for" .. _pieces[i][entry].Name .. ", item " .. i)
							print("Name:", name)
							print("Value array:", data[1])
							print("Type:", data[2])
							NewInstance:SetAttribute(name, GetValue(data[1], data[2]))
						end
					end
				]]--
				
				-- Also, if it had any tags, make sure this instance is tagged in the same way.
				if _pieces[i][entry].Tags then
					for _,tag in _pieces[i][entry].Tags do
						NewInstance:AddTag(tag)
					end
				end
			end
		end
		
		-- Now that all of the Instances are here, let's give them all of their intended property values!
		local temp_value
		for i,piece in _pieces do
			-- Both of these functions are wrapped in pcalls so no errors can stop the import before it finishes (hopefully).
			local success1, errormsg1 = pcall(function()
				for entry,inst in piece do
					local success2, errormsg2 = pcall(function()
						local temp_classname				= inst.ClassName
						local temp_isforbidden : number?	= nil	-- If this instance is a Player or PlayerGui, it isn't allowed and will become a Model.
						if table.find(InvalidClasses, temp_classname) then temp_classname = "Model" end
						
						if Recreator.ClassData[temp_classname] then
							-- Page4_Message.Text					= "Setting properties of " .. entry .. "/" .. #_pieces[i] .. " from piece " .. i .. "..."
							Recreator.StatusGui.Text				= "Setting properties of " .. entry .. "/" .. #_pieces[i] .. " from piece " .. i .. "..."
							-- print("About to edit class", temp_classname)
							-- Any class-specific properties are set using its property list in ClassData. If a property's name starts
							-- with "UseCmnList_", a secondary list of properties is checked and added to this list.
							-- This code was copied from the script, just like that array.
							for property1 : string,type1 : string in Recreator.ClassData[temp_classname].Props do
								if property1:find("UseCmnList_") then
									if CommonPropList[type1] then
										-- print("Entering a common list,", type1)
										for property2 : string, type2 : string in CommonPropList[type1] do
											-- print("Applying", property2, "type", type2)
											-- Intentionally avoid updating any properties with nil values; When in doubt, stick to the defaults.
											temp_value = GetValue(inst[property2], type2)
											if typeof(temp_value) ~= "nil" then
												inst.Instance[property2] = temp_value
											-- else warn("Ignoring "..inst.Name.."'s "..property2.." because its"..type2.." value was "..tostring(temp_value))
											end
											
										end
										-- print("That was safe. Next!")
									end
								else	-- If this is a property listed inline for this class, just try to store its value in the dictionary entry.
									-- Intentionally avoid updating any properties with nil values; When in doubt, stick to the defaults.
									temp_value = GetValue(inst[property1], type1)
									-- print(GetValue(inst[property1], type1), temp_value)
									if typeof(temp_value) ~= "nil" then
										inst.Instance[property1] = temp_value
									-- else
										-- warn("Ignoring "..inst.Name.."'s "..property1.." because its"..type1.." value was "..tostring(temp_value))
									end
								end
							end
							
							-- Finally, find this Instance's parent and move it into them. First, see if any generated Instance is its parent.
							local ParentMatch : Instance? = GetValue(inst.Parent, "Instance")
							if ParentMatch then
								inst.Instance.Parent	= ParentMatch
							elseif ImposterDB[_header.PieceInfo[i].InsertLocation] then
								-- If this is an orphan, at least try to place it in the most appropriate container.
								inst.Instance.Parent = ImposterDB[_header.PieceInfo[i].InsertLocation]
							else
								warn("Xane's Model Recreator (Plugin) - Couldn't find a parent for " .. inst.Name .. "(of piece " .. i .. "). It's removed.")
								inst.Instance:Destroy()
							end
						else
							warn("Xane's Model Recreator (Plugin) - Unknown class " ..temp_classname .. " encountered. An instance wasn't included!")
							if inst.Instance then inst.Instance:Destroy() end	-- Delete the Instance to reduce garbage buildup.
						end
					end)
					if not success2 then
						warn("Xane's Model Recreator (Plugin) - Couldn't finish creating piece "..i.." entry "..entry.." because "..errormsg2)
					end
				end
			end)
			if not success1 then
				warn("Xane's Model Recreator (Plugin) - Failed to create piece "..i.." because "..errormsg1)
			end
		end
		
		if _header.LightingProperties and _config.ApplyLighting then
			Lighting.Ambient							= GetValue(_header.LightingProperties.Ambient, "Color3")
			Lighting.Brightness							= GetValue(_header.LightingProperties.Brightness, "number")
			Lighting.ColorShift_Bottom					= GetValue(_header.LightingProperties.ColorShift_Bottom, "Color3")
			Lighting.ColorShift_Top						= GetValue(_header.LightingProperties.ColorShift_Top, "Color3")
			Lighting.EnvironmentDiffuseScale			= GetValue(_header.LightingProperties.EnvironmentDiffuseScale, "number")
			Lighting.EnvironmentSpecularScale			= GetValue(_header.LightingProperties.EnvironmentSpecularScale, "number")
			Lighting.GlobalShadows						= GetValue(_header.LightingProperties.GlobalShadows, "boolean")
			Lighting.OutdoorAmbient						= GetValue(_header.LightingProperties.OutdoorAmbient, "Color3")
			Lighting.ShadowSoftness						= GetValue(_header.LightingProperties.ShadowSoftness, "number")
			Lighting.ClockTime							= GetValue(_header.LightingProperties.ClockTime, "number")
			Lighting.GeographicLatitude					= GetValue(_header.LightingProperties.GeographicLatitude, "number")
			Lighting.FogColor							= GetValue(_header.LightingProperties.FogColor, "Color3")
			Lighting.FogEnd								= GetValue(_header.LightingProperties.FogEnd, "number")
			Lighting.FogStart							= GetValue(_header.LightingProperties.FogStart, "number")
		end
		
		-- Check each container too see if any Instances ewere created inside of them. If nothing's found, remove it.
		for i,destInfo in ImposterDestInfo[#_header.ImposterIds] do
			if #ImposterDB[destInfo.AbbrevDestName]:GetChildren() < 1 then ImposterDB[destInfo.AbbrevDestName]:Destroy() end
		end
		if TempDirectory then TempDirectory:Destroy() end	-- Lastly, remove the MeshPart that everything was intiially created in. It's not needed now.
		table.clear(ImposterDB)
		table.clear(DebugIDList)
	end)
	
	if Recreator.StatusGui == built_in_status then
		built_in_status.Visible = false
	end
	
	Result.Success = success
	if not success then
		task.defer(function() DisplayError("Failed to import; A problem interrupted the process: " .. tostring(errormsg), 5) end)
	end
	return Result	-- Return whether the import was successful and the submodels it created if it was.
end
print("✅Import/load function created successfully!")

function Recreator.Load(_header : any, _pieces : {any}, _config : XRecreatorLoadConfig)
	local Result : XRecreatorImportResult	= {
		Success = false,	-- Assume failure by default.
		Workspace = nil,
		Players = nil,
		Lighting = nil,
		ReplicatedStorage = nil,
		StarterGui = nil,
		SoundService = nil,
		StarterPack = nil
	}
	
	if _header and _pieces and type(_header) == "table" and type(_pieces) == "table" and _pieces[1] and type(_pieces[1]) == "table" then
		if _header.Metadata and _header.LightingProperties then
			if _header.PieceInfo and _header.PieceInfo[1] then
				ImportAsset(_header, _pieces, _config)
			else
				DisplayError("Import failed! Header didn't contain any pieces.")
				return Result
			end
		else
			DisplayError("Import failed! It had an invalid header, missing a section.")
			return Result
		end
	else
		DisplayError("Import failed! Its header and/or piece array was missing or wasn't an array. If it's JSON, decode it first.", 7)
		return Result
	end
end

function Recreator.LoadFile(_saveName : string, _config : XRecreatorLoadConfig)
	local Result : XRecreatorImportResult	= {
		Success = false,	-- Assume failure by default.
		Workspace = nil,
		Players = nil,
		Lighting = nil,
		ReplicatedStorage = nil,
		StarterGui = nil,
		SoundService = nil,
		StarterPack = nil
	}
	
	if _saveName and type(_saveName) == "string" then
		-- Initially create empty variables for each file's contents; Each will get loaded/added as it's found.
		local header : any? = nil
		local pieces : {any?} = {}
		
		local success1, _ = pcall(function() header = readfile(_saveName .. "_header.json") end)
		if success1 then	-- If the header imports, decode it now, since it contains info about each piece.
			local success2, _ = pcall(function() header = HttpService:JSONDecode(header) end)
			if success2 and header.PieceInfo and header.PieceInfo[1] then
				for piece = 1, #header.PieceInfo do
					local newPiece = nil
					local success3, _ = pcall(function() newPiece = readfile(_saveName .. "_piece" .. piece .. ".json") end)
					if success3 then
						local success4, _ = pcall(function() newPiece = HttpService:JSONDecode(newPiece) end)
						if success4 then
							table.insert(pieces,newPiece)
						else
							DisplayError("LoadFile failed because piece "..piece.." couldn't be decoded from JSON.", 5)
							return Result
						end
					else
						DisplayError("LoadFile failed because piece " .. piece .. " couldn't be found.")
						return Result
					end
				end
				
				Result = Recreator.Load(header, pieces, _config)	-- With all pieces loaded and decoded into dictionaries, pass to Load()!
			else
				DisplayError("LoadFile failed because the save's header couldn't be decoded as JSON data, or was missing piece info!", 5)
				return Result
			end
		else
			DisplayError("LoadFile failed because '" .. _saveName .. "_header.json' wasn't found in your workspace folder.", 5)
			return Result
		end
	end
	
	return Result
end

print("✅Done! The Recreation API should be usable until you teleport!")

return true	-- If execution reached the end of this script, the API is now ready for use by other scripts!